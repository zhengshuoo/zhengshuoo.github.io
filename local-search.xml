<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>常用数据结构操作与算法的复杂度</title>
    <link href="/posts/019-time-complexity.html"/>
    <url>/posts/019-time-complexity.html</url>
    
    <content type="html"><![CDATA[<p>在描述算法复杂度时，经常用到O(1), O(n), O(logn), O(nlogn), O(n^2), 其中的n代表输入数据的量来对应<code>时间复杂度</code>或者<code>空间复杂度</code></p><ul><li>如果ax=N（a&gt;0，且a≠1），那么数x叫做以a为底N的对数，记作x=logaN，读作以a为底N的对数，其中a叫做对数的底数，N叫做真数。</li></ul><h2 id="常用数据结构操作与算法的复杂度">常用数据结构操作与算法的复杂度</h2><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/20240125172834.jpeg" alt=""></p><h2 id="参考">参考</h2><ol><li><a href="https://imgur.com/gallery/7tIk0/comment/727923588">https://imgur.com/gallery/7tIk0/comment/727923588</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RocketMQ ACL</title>
    <link href="/posts/018-rocketmq-acl.html"/>
    <url>/posts/018-rocketmq-acl.html</url>
    
    <content type="html"><![CDATA[<p>业务需要在同一网络下部署多套 RocketMQ 供多租户使用，并且需要做 ACL 以防止访问非本租户的 RocketMQ。</p><span id="more"></span><h2 id="现状">现状</h2><p>当前版本为 <code>4.3.0</code> ,RocketMQ 在 <code>4.4.0</code> 版本开始支持ACL,并且在 <code>4.5.2</code> 版本对ACL做了一些修复以及改进，因此本次需升级RocketMQ 到 <code>4.5.2</code> 版本。</p><ul><li><a href="https://github.com/apache/rocketmq/issues/1078">ISSUE-1078</a> - Fixed the issue that User can’t use mqadmin command normally if they don’t copy the tool.yml file to related fold and AclEnable flag is closed.</li><li><a href="https://github.com/apache/rocketmq/issues/1147">ISSUE-1147</a> - Fixed the issue that broker will report exception if open the aclEnable and enableDLegerCommitLog flag at the same time.</li><li><a href="https://github.com/apache/rocketmq/issues/1156">ISSUE-1156</a> - Add new mqadmin API for ACL configuration.</li><li><a href="https://github.com/apache/rocketmq/issues/1290">ISSUE-1290</a> - Support matching some acl ip range.</li></ul><h2 id="ACL介绍">ACL介绍</h2><p>详细配置请参考<a href="https://rocketmq.apache.org/zh/docs/4.x/bestPractice/04access">官方文档</a></p><h3 id="什么是ACL">什么是ACL</h3><p>ACL是access control list的简称，俗称访问控制列表。访问控制，基本上会涉及到用户、资源、权限、角色等概念，那在RocketMQ中上述会对应哪些对象呢？</p><ul><li>用户:用户是访问控制的基础要素，也不难理解，RocketMQ ACL必然也会引入用户的概念，即支持用户名、密码。</li><li>资源:资源，需要保护的对象，在RocketMQ中，消息发送涉及的Topic、消息消费涉及的消费组，应该进行保护，故可以抽象成资源。</li><li>权限:针对资源，能进行的操作，</li><li>角色:RocketMQ中，只定义两种角色：是否是管理员。</li></ul><h3 id="基本流程">基本流程</h3><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/20230526171338.png" alt="20230526171338"></p><ol><li>先将对应的权限控制属性（包括Topic访问权限、IP白名单和AccessKey和SecretKey签名等）设置在distribution/conf/plain_acl.yml的配置文件中。</li><li>Client客户端通过 RPCHook 注入AccessKey和Signature（根据SecretKey 签名得到的字符串）；</li><li>Broker端对AccessKey所拥有的权限进行解析&amp;校验，校验不过，抛出异常；</li></ol><h3 id="权限校验">权限校验</h3><p>Broker端对权限的校验逻辑主要分为以下几步：</p><ol><li>检查是否命中全局 IP 白名单；如果是，则认为校验通过；否则走 2；</li><li>检查是否命中用户 IP 白名单；如果是，则认为校验通过；否则走 3；</li><li>校验签名，校验不通过，抛出异常；校验通过，则走 4；</li><li>对用户请求所需的权限 和 用户所拥有的权限进行校验；不通过，抛出异常；</li></ol><p>用户所需权限的校验需要注意已下内容：</p><ol><li>特殊的请求例如 UPDATE_AND_CREATE_TOPIC 等，只能由 admin 账户进行操作；</li><li>对于某个资源，如果有显性配置权限，则采用配置的权限；如果没有显性配置权限，则采用默认的权限；</li></ol><h2 id="实操">实操</h2><h3 id="客户端">客户端</h3><p>发送消息，接收消息的时候指定 RPCHook。</p><h4 id="AclClientRPCHook">AclClientRPCHook</h4><ol><li>parseRequestContent 方法内部方法将 request 的自定义头部上面的所有字段的 name 和 value 放入到了一个 SortedMap 中，同时将 ACCESS_KEY 和 SECURITY_TOKEN (如果有)也放入了进去</li><li>将上述所有字段的值拼接城字符串，然后获取字节数组，再与请求本身的 body 的字节数组拼接在一起，获取到最终的 byte[] 数组。</li><li>然后通过 calSignature 方法计算签名，在内部默认采用 SigningAlgorithm.HmacSHA1 算法获取到签名后的 byte[] 数组，再通过 Base64.encodeBase64 将其转为字符串，返回最终的签名。</li><li>生成签名以后，将签名、ACCESS_KEY、SECURITY_TOKEN (如果有) 添加到请求的扩展字段中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AclClientRPCHook</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RPCHook</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBeforeRequest</span><span class="hljs-params">(String remoteAddr, RemotingCommand request)</span> &#123;<br>        <span class="hljs-comment">// Add AccessKey and SecurityToken into signature calculating.</span><br>        request.addExtField(ACCESS_KEY, sessionCredentials.getAccessKey());<br>        <span class="hljs-comment">// The SecurityToken value is unnecessary,user can choose this one.</span><br>        <span class="hljs-keyword">if</span> (sessionCredentials.getSecurityToken() != <span class="hljs-literal">null</span>) &#123;<br>            request.addExtField(SECURITY_TOKEN, sessionCredentials.getSecurityToken());<br>        &#125;<br>        <span class="hljs-type">byte</span>[] total = AclUtils.combineRequestContent(request, parseRequestContent(request));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> AclUtils.calSignature(total, sessionCredentials.getSecretKey());<br>        request.addExtField(SIGNATURE, signature);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAfterResponse</span><span class="hljs-params">(String remoteAddr, RemotingCommand request, RemotingCommand response)</span> &#123;<br><br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Producer-示例">Producer 示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MESSAGE_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PRODUCER_GROUP</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;please_rename_unique_group_name&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_NAMESRVADDR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;127.0.0.1:9876&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TOPIC</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;TopicTest&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TAG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;TagA&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MQClientException, InterruptedException &#123;<br>        <span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(PRODUCER_GROUP,getAclRPCHook());<br>        producer.setNamesrvAddr(DEFAULT_NAMESRVADDR);<br>        producer.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(TOPIC, TAG , (<span class="hljs-string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));<br>                <span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.send(msg);<br>                System.out.printf(<span class="hljs-string">&quot;%s%n&quot;</span>, sendResult);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125;<br>        &#125;<br>        producer.shutdown();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RPCHook <span class="hljs-title function_">getAclRPCHook</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AclClientRPCHook</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SessionCredentials</span>(<span class="hljs-string">&quot;rocketmq&quot;</span>,<span class="hljs-string">&quot;12345678&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Consumer-示例">Consumer 示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CONSUMER_GROUP</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;please_rename_unique_group_name_4&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_NAMESRVADDR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;127.0.0.1:9876&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TOPIC</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;TopicTest&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, MQClientException &#123;<br>        <span class="hljs-type">DefaultMQPushConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQPushConsumer</span>(<span class="hljs-literal">null</span>, CONSUMER_GROUP, getAclRPCHook());<br>        consumer.setNamesrvAddr(DEFAULT_NAMESRVADDR);<br>        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);<br>        consumer.subscribe(TOPIC, <span class="hljs-string">&quot;*&quot;</span>);<br>        consumer.registerMessageListener((MessageListenerConcurrently) (msg, context) -&gt; &#123;<br>            System.out.printf(<span class="hljs-string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msg);<br>            <span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;<br>        &#125;);<br>        consumer.start();<br>        System.out.printf(<span class="hljs-string">&quot;Consumer Started.%n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RPCHook <span class="hljs-title function_">getAclRPCHook</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AclClientRPCHook</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SessionCredentials</span>(<span class="hljs-string">&quot;rocketmq&quot;</span>,<span class="hljs-string">&quot;12345678&quot;</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="服务端">服务端</h3><h4 id="配置ACL">配置ACL</h4><ol><li>升级RocketMQ服务端至4.5.2</li><li>broker.conf 开启ACL 增加 aclEnable=true</li><li>配置权限、添加账户、slave节点ip添加到全局白名单</li></ol><ul><li><p>如果ACL与高可用部署(Master/Slave架构)同时启用，那么需要在Broker Master节点的distribution/conf/plain_acl.yml配置文件中 设置全局白名单信息，即为将Slave节点的ip地址设置至Master节点plain_acl.yml配置文件的全局白名单中。</p></li><li><p>如果ACL与高可用部署(多副本Dledger架构)同时启用，由于出现节点宕机时，Dledger Group组内会自动选主，那么就需要将Dledger Group组 内所有Broker节点的plain_acl.yml配置文件的白名单设置所有Broker节点的ip地址。</p></li></ul><blockquote><p>由于只需要做租户隔离，这里配置admin=true，细粒度权限请参考官方文档</p></blockquote><ul><li><p>在 plain_acl.yml 配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 全局ip白名单</span><br><span class="hljs-attr">globalWhiteRemoteAddresses:</span><br><span class="hljs-bullet">-</span> <span class="hljs-number">10.10</span><span class="hljs-number">.103</span><span class="hljs-string">.*</span><br><span class="hljs-bullet">-</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-string">.*</span><br><br><span class="hljs-comment"># 账户</span><br><span class="hljs-attr">accounts:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">accessKey:</span> <span class="hljs-string">rocketmq</span><br>    <span class="hljs-attr">secretKey:</span> <span class="hljs-number">12345678</span><br>    <span class="hljs-attr">whiteRemoteAddress:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-string">.*</span><br><span class="hljs-comment"># if it is admin, it could access all resources</span><br>    <span class="hljs-attr">admin:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>mqadmin 命令配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 添加/更行账号</span><br><span class="hljs-string">sh</span> <span class="hljs-string">mqadmin</span> <span class="hljs-string">updateAclConfig</span> <span class="hljs-string">-n</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span><span class="hljs-string">:9876</span> <span class="hljs-string">-b</span> <span class="hljs-number">192.168</span><span class="hljs-number">.12</span><span class="hljs-number">.134</span><span class="hljs-string">:10911</span> <span class="hljs-string">-a</span> <span class="hljs-string">RocketMQ</span> <span class="hljs-string">-s</span> <span class="hljs-number">12345678</span> <span class="hljs-string">-m</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 删除账号</span><br><span class="hljs-string">sh</span> <span class="hljs-string">mqadmin</span> <span class="hljs-string">deleteAccessConfig</span> <span class="hljs-string">-n</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span><span class="hljs-string">:9876</span> <span class="hljs-string">-c</span> <span class="hljs-string">DefaultCluster</span> <span class="hljs-string">-a</span> <span class="hljs-string">RocketMQ</span><br><br><span class="hljs-comment"># 更新全局白名单</span><br><span class="hljs-string">$</span> <span class="hljs-string">sh</span> <span class="hljs-string">mqadmin</span> <span class="hljs-string">updateGlobalWhiteAddr</span> <span class="hljs-string">-n</span> <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.2</span><span class="hljs-string">:9876</span> <span class="hljs-string">-b</span> <span class="hljs-number">192.168</span><span class="hljs-number">.12</span><span class="hljs-number">.134</span><span class="hljs-string">:10911</span> <span class="hljs-string">-g</span> <span class="hljs-number">10.10</span><span class="hljs-number">.154</span><span class="hljs-number">.1</span><span class="hljs-string">,10.10.154.2</span><br></code></pre></td></tr></table></figure><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/20230526182704.png" alt="20230526182704"></p></li></ul><h4 id="启动命令">启动命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动 nameserver</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载启动</span><br>nohup sh bin/mqnamesrv &amp; <br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看日志</span>   <br>tail -f ~/logs/rocketmqlogs/namesrv.log   <br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动 broker</span><br>nohup sh bin/mqbroker -c conf/broker.conf -n localhost:9876 &amp;    <br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看日志</span>  <br>tail -f ~/logs/rocketmqlogs/broker.log<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭</span><br>sh bin/mqshutdown broker<br>sh bin/mqshutdown namesrv<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">发送消息</span><br>export NAMESRV_ADDR=localhost:9876<br>sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer<br><span class="hljs-meta prompt_"># </span><span class="language-bash">接收消息</span><br>sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看集群状态</span><br>sh bin/mqadmin clusterList -n &quot;127.0.0.1:9876&quot;<br></code></pre></td></tr></table></figure><p>查看集群状态若权限不对显示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  rocketmq sh bin/mqadmin clusterList -n &quot;127.0.0.1:9876&quot;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">Cluster Name     <span class="hljs-comment">#Broker Name            #BID  #Addr                  #Version                #InTPS(LOAD)       #OutTPS(LOAD) #PCWait(ms) #Hour #SPACE</span></span><br>org.apache.rocketmq.client.exception.MQBrokerException: CODE: 1  DESC: org.apache.rocketmq.acl.common.AclException: No acl config for rocketmq222, org.apache.rocketmq.acl.plain.PlainPermissionManager.validate(PlainPermissionManager.java:667) BROKER: 10.94.30.17:10911<br>For more information, please visit the url, http://rocketmq.apache.org/docs/faq/<br> at org.apache.rocketmq.client.impl.MQClientAPIImpl.getBrokerRuntimeInfo(MQClientAPIImpl.java:1318)<br> at org.apache.rocketmq.tools.admin.DefaultMQAdminExtImpl.fetchBrokerRuntimeStats(DefaultMQAdminExtImpl.java:293)<br> at org.apache.rocketmq.tools.admin.DefaultMQAdminExt.fetchBrokerRuntimeStats(DefaultMQAdminExt.java:244)<br> at org.apache.rocketmq.tools.command.cluster.ClusterListSubCommand.printClusterBaseInfo(ClusterListSubCommand.java:212)<br> at org.apache.rocketmq.tools.command.cluster.ClusterListSubCommand.execute(ClusterListSubCommand.java:88)<br> at org.apache.rocketmq.tools.command.MQAdminStartup.main0(MQAdminStartup.java:149)<br> at org.apache.rocketmq.tools.command.MQAdminStartup.main(MQAdminStartup.java:100)<br>DefaultCluster    broker-a                0     10.94.30.17:10911                                 0.00(,ms)           0.00(,ms)             0.00 0.0000<br></code></pre></td></tr></table></figure><h2 id="参考">参考</h2><ol><li><a href="https://rocketmq.apache.org/zh/docs/4.x/bestPractice/04access">https://rocketmq.apache.org/zh/docs/4.x/bestPractice/04access</a></li><li><a href="https://kunzhao.org/docs/rocketmq/rocketmq-acl/">https://kunzhao.org/docs/rocketmq/rocketmq-acl/</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>RocketMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RocketMQ</tag>
      
      <tag>ACL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Doris On Yarn</title>
    <link href="/posts/017-doris-on-yarn.html"/>
    <url>/posts/017-doris-on-yarn.html</url>
    
    <content type="html"><![CDATA[<p>本文讲述基于 Yarn 动态的部署 Doris BE 服务，以实现 Doris 和 Hadoop 集群资源利用率最大化。</p><span id="more"></span><h2 id="背景">背景</h2><p>目前 Doris 在公司内共部署了 3 个集群，具体信息如下：</p><ul><li><p>测试集群</p><p>提供给 Doris 控制台做建表脚本测试，稳定性保障不高。</p></li><li><p>报表集群</p><p>数据分析人员使用，通过将数仓部分 Hive 表直接同步到该集群，并且通过一些 BI 工具（帆软 、观远 等）做报表分析，数据规模不大，但是稳定性需要严格保障。</p></li><li><p>标签集群</p><p>目前是给离线标签集群替换 es 来作为高效查询使用，因为是线上业务，稳定性也需要严格保障。</p></li></ul><p>自助查询规划通过 Doris 加速查询性能，标签集群最开始是规划给自助查询使用，但是因为数据导入成本太高放弃使用，但还是需要一种方式能够对自助查询提供加速。</p><h2 id="Doris">Doris</h2><p>Doris 1.2.0 后新增两个特性</p><ul><li><p>多源数据目录（Multi-Catalog）</p><p>旨在能够更方便对接外部数据目录，以增强 Doris 的数据湖分析和联邦数据查询能力。构成 Catalog -&gt; Database -&gt; Table 的三层元数据层级，Catalog 可以直接对应到外部数据目录，很方便拿到所有 Database 映射。</p></li><li><p>计算节点（computation）</p><p>计算节点专门处理数据湖这类远程的联邦查询. 原来的 BE 节点类型称为混合节点, 这类节点既能做 SQL 查询, 又有 Tablet 数据存储管理. 而计算节点只能做 SQL 查询, 它不会保存任何数据.</p></li></ul><blockquote><p>混合节点又可以查询，又可以存储，为什么还需要计算节点？</p></blockquote><ul><li>资源隔离差, 两个负载对集群的响应要求不一, 混合部署会有相互的影响.</li><li>集群扩容时, 数据湖查询只需要扩容计算资源, 而目前只能存储计算一起扩容, 导致磁盘使用率变低.</li><li>扩容效率差, 扩容后会启动 Tablet 数据的迁移, 整体过程比较漫长. 而数据湖查询有着明显的高峰低谷, 需要小时级弹性能力.</li></ul><p>同时由于没有多余的资源部署计算节点，计算节点是无状态的，考虑资源合理使用的问题，我们需要探索是否可以基于 Hadoop Yarn 动态的部署 Doris BE 服务，以实现 Doris 和 Hadoop 集群资源的最大化复用, 这里使用 Skein 部署 Doris BE 服务。</p><h2 id="Skein">Skein</h2><p>Skein 是一个用于在 Apache Hadoop 集群上运行和管理分布式应用程序的开源框架</p><h3 id="架构">架构</h3><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/20230523030041.png" alt="20230523030041"></p><ul><li><p>Application Master（应用程序主节点）：<br>Skein 的核心组件是 Application Master，它是一个运行在 YARN 上的 Java 进程，负责解释和执行应用程序的规范（Specification）。Application Master 管理应用程序的整个生命周期，包括资源的申请和分配、容器的启动和监控、任务的调度和执行等。它与 YARN ResourceManager 进行通信，并协调各个任务的执行。</p></li><li><p>Specification（规范）：<br>Skein 使用规范来描述和定义应用程序的各个组件、资源需求、启动命令等。规范以 JSON 格式表示，并包含了应用程序的配置信息、依赖项、服务定义等。Application Master 根据规范来启动和管理应用程序。</p></li><li><p>Services（服务）：<br>Skein 的规范可以定义多个服务，每个服务代表一个应用程序组件或服务。服务可以是一个用户定义的进程、容器、Web 服务等。Application Master 负责启动、监控和管理这些服务，并提供与它们的交互接口。</p></li><li><p>Container（容器）：<br>在 Skein 中，容器是应用程序的基本执行单元。Application Master 通过向 YARN 请求资源来获取容器，并在这些容器中运行应用程序的服务和任务。每个容器都有自己的资源限制和环境设置，可以独立地执行任务。</p></li></ul><p>总体而言，Skein 的架构包括一个 Application Master 负责应用程序的管理，规范定义应用程序的组件和配置，服务代表应用程序的各个组件，容器是执行任务的基本单位。通过这种架构，Skein 实现了在 YARN 上运行和管理分布式应用程序的能力。</p><h3 id="skein-配置文件">skein 配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">name: doris<br>queue: doris<br>node_label: doris<br>master:<br>  log_level: debug<br>services:<br>  doris.be:<br>    instances: 128<br>    resources:<br>      memory: 64 GiB<br>      vcores: 8<br>    # 服务允许的最大重启次数，-1 以始终重新启动<br>    max_restarts: -1<br>    # 运行服务所需的文件<br>    files:<br>      doris_be: hdfs:///user/bolt/doris/doris-be-1.2.4.tar.gz<br>      doris_sh: hdfs:///user/bolt/doris/doris-be.sh<br>      be_conf: hdfs:///user/bolt/doris/be.conf<br>    # 运行服务的bash脚本<br>    script: |<br>      sh doris_sh $(readlink -f doris_be) $(readlink -f be_conf)<br>      exit $?<br></code></pre></td></tr></table></figure><p>从上述配置问价可看出，这里会部署 128 台 8C64G 的 container 到 Yarn 中的 Doris 队列 Doris 标签节点上，启动脚本为 doris_sh。</p><h3 id="doris-be-sh"><a href="http://doris-be.sh">doris-be.sh</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>DORIS_BE_PATH=$1<br>CONF_DIR=$2<br><br>DORIS_VERSION=1.2.4<br>LOG_PATH=&quot;/tmp/doris/log&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出脚本日志到 /doris-on-yarn.log</span><br>function echo_log() &#123;<br>  echo &quot;$(date &quot;+%Y-%m-%d %H:%M:%S&quot;): $@&quot; | tee -a &quot;$&#123;LOG_PATH&#125;/doris-on-yarn.log&quot;<br>&#125;<br><br>mkdir -p &quot;$&#123;LOG_PATH&#125;&quot;<br><br>echo_log &quot;$&#123;DORIS_BE_PATH&#125;&quot;<br>echo_log &quot;$&#123;CONF_DIR&#125;&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">set</span> conf</span><br>/bin/cp -f $&#123;CONF_DIR&#125; &quot;$&#123;DORIS_BE_PATH&#125;/apache-doris-be-$&#123;DORIS_VERSION&#125;-bin-x86_64/conf/be.conf&quot;<br>sed -i &#x27;s#export LOG_DIR=&quot;\$&#123;DORIS_HOME&#125;/log&quot;#export LOG_DIR=&quot;/tmp/doris/log&quot;#g&#x27; &quot;$&#123;DORIS_BE_PATH&#125;/apache-doris-be-$&#123;DORIS_VERSION&#125;-bin-x86_64/bin/start_be.sh&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Start the BE</span><br>echo_log &quot;-------- Starting Doris BE $(hostname -I) --------&quot;<br>&quot;$&#123;DORIS_BE_PATH&#125;/apache-doris-be-$&#123;DORIS_VERSION&#125;-bin-x86_64/bin/start_be.sh&quot;<br>exit $?<br></code></pre></td></tr></table></figure><ol><li>复制自定义 be.conf 到 doris conf 目录</li><li>container 会销毁，不便于查看日志，因此把日志输出到机器的 <code>/tmp/doris/log</code> 下</li><li>启动 Doris-be</li></ol><blockquote><p>为什么要 exit $?</p></blockquote><p>配置了 <code>max_restarts: -1</code> container 失败一直重启，需要把失败状态码传递到 Application Master，才会重新分配资源重新启动。</p><h3 id="相关命令">相关命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动命令</span><br>skein submit doris-be.yaml<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 application</span><br>skein application ls<br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止</span><br>skein shutdown &lt;APP_ID&gt;<br></code></pre></td></tr></table></figure><h3 id="Yarn-资源分配策略">Yarn 资源分配策略</h3><p>在实践中发现，由于并不是 128 台 Be 都启动了，因此需要去了解 Yarn 的资源分配策略进行优化</p><p>在 YARN 中，Application 的 Container 异常崩溃后不会自动恢复。当一个 Container 发生异常崩溃时，YARN 会将该 Container 标记为失败，并通知 ResourceManager。ResourceManager 会记录该 Container 的失败状态，并可以采取相应的操作，例如重新分配资源或记录日志。</p><p>以下是一般情况下 YARN 重新分配资源的策略：</p><ol><li>资源重新分配：ResourceManager 会尝试重新为失败的 Container 分配资源，以满足 Application 的需求。资源的重新分配可能会在同一节点上或其他可用节点上进行。</li><li>容器优先级：重新分配资源时，ResourceManager 会考虑容器的优先级。较高优先级的容器可能会被优先重新分配资源，以确保重要的任务能够快速恢复。</li><li>容器位置约束：根据配置和调度策略，ResourceManager 可能会尽量将重新分配的容器分配到特定的节点或节点标签上，以满足应用程序的需求。</li><li>容器重试限制：ResourceManager 通常会限制容器的重试次数。如果一个容器连续失败超过预设的重试次数限制，ResourceManager 可能会认为该容器无法成功运行，并不再重新分配资源给它。（目前 doris 失败重试过一段时间不在继续重试原因）</li></ol><h4 id="资源调度器">资源调度器</h4><h5 id="FIFO-Scheduler-先进先出调度器">FIFO Scheduler(先进先出调度器)</h5><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/20230523022449.png" alt="20230523022449"></p><p>将所有的 Application 按照提交时候的顺序来执行，只有当上一个 Job 执行完成之后后面的 Job 才会按照队列的顺序依次被执行。FIFO 调度器以集群资源独占的方式来运行作业，后面的 Job 会被阻塞。简单但不实用。</p><h5 id="Fair-Scheduler-公平调度器">Fair Scheduler(公平调度器)</h5><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/20230523022322.png" alt="20230523022322"></p><p>所有的 Job 平均的获取资源。默认情况下，Fair 调度器只是对内存资源做公平的调度和分配。多个队列会平分资源，队列内的 Job 也会平分资源。</p><h5 id="Capacity-Scheduler-容量调度器-（我们使用的）">Capacity Scheduler(容量调度器)（我们使用的）</h5><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/image.png.png" alt="image.png"></p><p>相关参数：</p><ul><li><p>capacity：队列的资源容量（百分比）。 当系统非常繁忙时，应保证每个队列的容量得到满足，而如果每个队列应用程序较少，可将剩余资源共享给其他队列。</p></li><li><p>maximum-capacity：队列的资源使用上限（百分比）。由于存在资源共享，因此一个队列使用的资源量可能超过其容量，而最多使用资源量可通过该参数限制。（这也是前文提到的关于有任务运行的队列可以占用的资源的最大百分比）</p></li><li><p>user-limit-factor：每个用户最多可使用的队列资源量，默认 1（100%）。</p></li></ul><blockquote><p>假如整个集群有 10 台 100G 机器，其中有 5 台 label 为 doris，剩余 5 台 label 为 other，A 队列配置 label 为 doris，B 队列配置 label 为 other，c 队列配置 label 为 doris 和 other，A 队列 Capacity 为 10%,B 队列 Capacity 为 10%,C 队列 Capacity 为 10%，请问 A 队列实际能使用的容量是多少？</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">A: 5 * 100G * 10% = 50GB<br>B: 5 * 100G * 10% = 50GB<br>C: (5+5) * 100G * 10% = 100GB<br></code></pre></td></tr></table></figure><p>我们实际 Doris 队列原本 Capacity 为 10%，不足以满足 128 个 Be 内存需求，有上面例子可以计算出我们实际需要的 Capacity 为 25%（具体数据不列举），同时运行的 Be 平均 70 个增加到 100 个，理想情况下能够同时运行 128 个 Be（只发现过一次）。</p><p>为什么很难到达 128 个呢，由于端口冲突一台 node 只能起一个 Doris container，ResourceManager 分配是按容量分配资源，而不是按每个 Node 分配一个 container，以及 ResourceManager 容器重试次数限制，因此大部分情况下并不能 128 个都启动。</p><h2 id="总结">总结</h2><p>本文简单介绍了如何基于 Yarn 动态的部署 Doris BE 服务，同时了解到 Yarn 资源分配策略。这对我们理解大数据生态带来一些启发。</p><h2 id="参考">参考</h2><ol><li><a href="https://jcristharif.com/skein/quickstart.html">https://jcristharif.com/skein/quickstart.html</a></li><li><a href="https://doris.apache.org/zh-CN/">https://doris.apache.org/zh-CN/</a></li><li><a href="https://zhuanlan.zhihu.com/p/27953843">https://zhuanlan.zhihu.com/p/27953843</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>MPP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Doris</tag>
      
      <tag>Yarn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Helm 实践</title>
    <link href="/posts/016-helm-Practice.html"/>
    <url>/posts/016-helm-Practice.html</url>
    
    <content type="html"><![CDATA[<p>工作需要批量部署同一套ToB（to business）服务到多个k8s cluster/namespace 上，经过几百根头发的研究，本文介绍Helm的实践（踩的坑）。</p><span id="more"></span><p>我们希望可以通过脚本一键、按顺序部署一套服务到指定的k8s cluster/namespace 上</p><h2 id="部署">部署</h2><h3 id="状态检查">状态检查</h3><p>在 <code>kubectl</code>，我们可以用 <code>kubectl rollout status</code> 检查部署的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># kubectl rollout status deployment/probe-busybox -n tenant-test</span><br>Waiting <span class="hljs-keyword">for</span> rollout to finish: 2 out of 3 new replicas have been updated...<br>deployment <span class="hljs-string">&quot;probe-busybox&quot;</span> successfully rolled out<br><br><span class="hljs-comment"># kubectl get deployments deployment/probe-busybox -n tenant-test</span><br>NAME               READY   UP-TO-DATE   AVAILABLE   AGE<br>probe-busybox   3/3     3            3           18s<br></code></pre></td></tr></table></figure><p>那么在这种情况下，Helm 的等价物是什么？</p><p><code>--wait</code> Helm 将等到部署中启动了最少预期数量的 Pod，然后再将发布标记为成功。</p><p><code>--timeout</code> --wait 超时时间时间，默认情况下，超时时间为 300 秒。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ helm upgrade --install --<span class="hljs-built_in">wait</span> --<span class="hljs-built_in">timeout</span> 30s probe-busybox probe-busybox/ -n tenant-test<br>Release <span class="hljs-string">&quot;probe-busybox&quot;</span> does not exist. Installing it now.<br>NAME: probe-busybox<br>LAST DEPLOYED: Tue Mar 14 15:04:38 2023<br>NAMESPACE: tenant-test<br>STATUS: deployed<br>REVISION: 1<br></code></pre></td></tr></table></figure><p>部署按预期成功完成。让我们看看当我们尝试使用失败的部署时会发生什么。设置就绪检查错误端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ helm upgrade --install --<span class="hljs-built_in">wait</span> --<span class="hljs-built_in">timeout</span> 30s probe-busybox probe-busybox/ -n tenant-test --<span class="hljs-built_in">set</span> readinessProbe.tcpSocket.port=8081<br>Error: UPGRADE FAILED: timed out waiting <span class="hljs-keyword">for</span> the condition<br><br>$ helm <span class="hljs-built_in">history</span> probe-busybox -n tenant-test<br>REVISION        UPDATED                         STATUS          CHART           APP VERSION     DESCRIPTION                                                        <br>1               Tue Mar 14 15:04:38 2023        deployed        chart-tpl-0.1.0 1.16.0          Install complete                                                   <br>2               Tue Mar 14 15:07:49 2023        failed          chart-tpl-0.1.0 1.16.0          Upgrade <span class="hljs-string">&quot;probe-busybox&quot;</span> failed: timed out waiting <span class="hljs-keyword">for</span> the condition<br><br></code></pre></td></tr></table></figure><h3 id="回滚">回滚</h3><ul><li>手动部署一个正确的 release</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ helm upgrade --install --<span class="hljs-built_in">wait</span> --<span class="hljs-built_in">timeout</span> 30s probe-busybox probe-busybox/ -n tenant-test<br>Release <span class="hljs-string">&quot;probe-busybox&quot;</span> has been upgraded. Happy Helming!<br>NAME: probe-busybox<br>LAST DEPLOYED: Tue Mar 14 15:10:10 2023<br>NAMESPACE: tenant-test<br>STATUS: deployed<br>REVISION: 3<br><br>$ helm <span class="hljs-built_in">history</span> probe-busybox -n tenant-test                                              <br>REVISION        UPDATED                         STATUS          CHART           APP VERSION     DESCRIPTION                                                        <br>1               Tue Mar 14 15:04:38 2023        superseded      chart-tpl-0.1.0 1.16.0          Install complete                                                   <br>2               Tue Mar 14 15:07:49 2023        failed          chart-tpl-0.1.0 1.16.0          Upgrade <span class="hljs-string">&quot;probe-busybox&quot;</span> failed: timed out waiting <span class="hljs-keyword">for</span> the condition<br>3               Tue Mar 14 15:10:10 2023        deployed        chart-tpl-0.1.0 1.16.0          Upgrade complete   <br></code></pre></td></tr></table></figure><ul><li>手动回滚<code>helm rollback</code> 将版本回滚到以前的版本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$  helm rollback --<span class="hljs-built_in">wait</span> --<span class="hljs-built_in">timeout</span> 30s probe-busybox 1 -n tenant-test<br>Rollback was a success! Happy Helming!<br><br>$  helm <span class="hljs-built_in">history</span> probe-busybox -n tenant-test         <br>REVISION        UPDATED                         STATUS          CHART           APP VERSION     DESCRIPTION                                                        <br>1               Tue Mar 14 15:04:38 2023        superseded      chart-tpl-0.1.0 1.16.0          Install complete                                                   <br>2               Tue Mar 14 15:07:49 2023        failed          chart-tpl-0.1.0 1.16.0          Upgrade <span class="hljs-string">&quot;probe-busybox&quot;</span> failed: timed out waiting <span class="hljs-keyword">for</span> the condition<br>3               Tue Mar 14 15:10:10 2023        superseded      chart-tpl-0.1.0 1.16.0          Upgrade complete                                                   <br>4               Tue Mar 14 15:13:07 2023        deployed        chart-tpl-0.1.0 1.16.0          Rollback to 1     <br></code></pre></td></tr></table></figure><ul><li>自动回滚<code>--atomic</code>   在升级失败的情况下回滚所做的更改</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ helm upgrade --install --atomic --<span class="hljs-built_in">timeout</span> 30s probe-busybox probe-busybox/ -n tenant-test --<span class="hljs-built_in">set</span> readinessProbe.tcpSocket.port=8081          <br>Error: UPGRADE FAILED: release probe-busybox failed, and has been rolled back due to atomic being <span class="hljs-built_in">set</span>: timed out waiting <span class="hljs-keyword">for</span> the condition<br><br>$ helm <span class="hljs-built_in">history</span> probe-busybox -n tenant-test                                                                                         <br>REVISION        UPDATED                         STATUS          CHART           APP VERSION     DESCRIPTION                                                        <br>1               Tue Mar 14 15:04:38 2023        superseded      chart-tpl-0.1.0 1.16.0          Install complete                                                   <br>2               Tue Mar 14 15:07:49 2023        failed          chart-tpl-0.1.0 1.16.0          Upgrade <span class="hljs-string">&quot;probe-busybox&quot;</span> failed: timed out waiting <span class="hljs-keyword">for</span> the condition<br>3               Tue Mar 14 15:10:10 2023        superseded      chart-tpl-0.1.0 1.16.0          Upgrade complete                                                   <br>4               Tue Mar 14 15:13:07 2023        superseded      chart-tpl-0.1.0 1.16.0          Rollback to 1                                                      <br>5               Tue Mar 14 15:15:10 2023        failed          chart-tpl-0.1.0 1.16.0          Upgrade <span class="hljs-string">&quot;probe-busybox&quot;</span> failed: timed out waiting <span class="hljs-keyword">for</span> the condition<br>6               Tue Mar 14 15:15:43 2023        deployed        chart-tpl-0.1.0 1.16.0          Rollback to 4          <br></code></pre></td></tr></table></figure><h3 id="问题">问题</h3><p>Helm 支持开箱即用的检查部署和自动回滚，但有下面两个问题。</p><ul><li>没有提供类似于<code>kubectl rollout status </code>检查部署的状态,<code>echo $?</code>返回为 0 代表成功的命令，可以通过轮询 <code>helm status</code> 检测 status 为 deployed （有点麻烦）。</li><li>超时时间是全局的，而pod数量并不确定，如果预估超时时间过短，未等到pod全部部署成功就会失败。如果预估超时时间过长，会浪费无谓的等待时间。</li></ul><h2 id="一键部署">一键部署</h2><h3 id="目录结构">目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm/<br>  bin                     <span class="hljs-comment"># 执行脚本</span><br>  chart-tpl               <span class="hljs-comment"># 模板目录</span><br>    Chart.yaml/           <span class="hljs-comment"># 包含了chart信息的YAML文件</span><br>    templates/            <span class="hljs-comment"># 模板目录</span><br>      deployment.yaml     <span class="hljs-comment"># 创建Kubernetes 工作负载的基本清单</span><br>      service.yaml        <span class="hljs-comment"># 为你的工作负载创建一个 service 终端基本清单。</span><br>      _helpers.tpl        <span class="hljs-comment"># 放置可以通过chart复用的模板辅助对象</span><br>      NOTES.txt           <span class="hljs-comment"># chart的&quot;帮助文本&quot;</span><br>  conf/<br>    secrets/<br>      secrets.probe-busybox.yaml <span class="hljs-comment"># 加密配置</span><br>      ...<br>    values/<br>      common.yaml       <span class="hljs-comment"># 公共配置</span><br>      infra/            <span class="hljs-comment"># 中间件服务</span><br>        apollo-portal.yaml <br>        apollo-adminservice.yaml<br>      other/            <span class="hljs-comment"># 其它服务</span><br>        probe-busybox.yaml<br>releases/<br>  000000/<br>    images/<br>      java_images.txt   <span class="hljs-comment"># 镜像版本信息</span><br></code></pre></td></tr></table></figure><p>为了实现一键批量部署，对 Chart 进行了一些改造，通过创建一个通用的 Chart 模板来支持多个服务的安装。</p><ul><li>通过在 <code>_helpers.tpl</code> 创建模板，并在 yaml 中引用以及流控制等方式创建 yaml 通用模板</li><li>common.yaml 为公共配置，提供默认值以及全局配置，会默认加载。</li><li>service.yaml 位对应服务个性化配置，会覆盖 common.yaml 配置。</li><li>image 版本信息存储在 外部目录中，部署时加载外部 images.txt 中版本信息并通过 <code>--set image.address=xxx </code>设置</li><li>通过部署时传入的名称、版本号、命名空间实现一键批量部署升级到不通 namespace 中</li></ul><h3 id="Yaml-模板">Yaml 模板</h3><p>这里以 service.yaml为例</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">if</span> <span class="hljs-string">and</span> <span class="hljs-string">.Values.service</span> <span class="hljs-string">.Values.service.port</span> &#125;&#125;<br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> &#123;&#123; <span class="hljs-string">.Values.name</span> &#125;&#125;<span class="hljs-string">-svc</span><br>  <span class="hljs-attr">labels:</span><br>    &#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">include</span> <span class="hljs-string">&quot;chart-tpl.labels&quot;</span> <span class="hljs-string">.</span> <span class="hljs-string">|</span> <span class="hljs-string">nindent</span> <span class="hljs-number">4</span> &#125;&#125;<br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> &#123;&#123; <span class="hljs-string">.Values.service.type</span> &#125;&#125;<br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> &#123;&#123; <span class="hljs-string">.Values.service.port</span> &#125;&#125;<br>      <span class="hljs-attr">targetPort:</span> &#123;&#123; <span class="hljs-string">.Values.service.targetPort</span> &#125;&#125;<br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">tcp-&#123;&#123;</span> <span class="hljs-string">.Values.service.targetPort</span> <span class="hljs-string">&#125;&#125;-&#123;&#123;</span> <span class="hljs-string">.Values.service.port</span> <span class="hljs-string">&#125;&#125;</span><br>  <span class="hljs-attr">selector:</span><br>    &#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">include</span> <span class="hljs-string">&quot;chart-tpl.selectorLabels&quot;</span> <span class="hljs-string">.</span> <span class="hljs-string">|</span> <span class="hljs-string">nindent</span> <span class="hljs-number">4</span> &#125;&#125;<br>&#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> &#125;&#125;<br></code></pre></td></tr></table></figure><h3 id="公共配置">公共配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 默认公共配置，可被 -f APP_NAME.yaml 或 --set 覆盖</span><br>global:<br>  storageClassName: default-sc<br>  imagePullSecrets: [&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;123456key&quot;</span>&#125;]<br>  internalSubnetId: subnet-123456<br><br>name: <span class="hljs-string">&quot;&quot;</span><br>replicaCount: 1<br><br><span class="hljs-comment"># 镜像</span><br>image:<br>  address: <span class="hljs-string">&quot;&quot;</span><br>  pullPolicy: IfNotPresent<br><br>resources:<br>  limits:<br>    cpu: 2<br>    memory: 4Gi<br>  requests:<br>    cpu: 0.5<br>    memory: 2Gi<br><br><span class="hljs-built_in">env</span>:<br>  ENV: PRO<br>  IDC: default<br><br>podAnnotations: &#123;&#125;<br><br><span class="hljs-comment"># pvcs</span><br>pvcs: []<br><br><span class="hljs-comment"># 负载均衡</span><br>service:<br>  <span class="hljs-comment"># ClusterIP/LoadBalancer/NodePort</span><br>  <span class="hljs-built_in">type</span>: ClusterIP<br><br><span class="hljs-comment"># 存活检查</span><br>livenessProbe:<br>  successThreshold: 1<br>  failureThreshold: 5<br>  timeoutSeconds: 10<br>  periodSeconds: 60<br>  initialDelaySeconds: 60<br><br><span class="hljs-comment"># 就绪检查</span><br>readinessProbe:<br>  successThreshold: 1<br>  failureThreshold: 5<br>  timeoutSeconds: 10<br>  periodSeconds: 60<br>  initialDelaySeconds: 60<br></code></pre></td></tr></table></figure><h3 id="服务配置">服务配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 容器名</span><br>name: <span class="hljs-string">&quot;probe-busybox&quot;</span><br>replicaCount: 1<br><br><span class="hljs-comment"># 镜像</span><br>image:<br>  address: <span class="hljs-string">&quot;&quot;</span><br>  pullPolicy: IfNotPresent<br><br><span class="hljs-comment"># 存活检查</span><br>livenessProbe:<br>  tcpSocket:<br>    port: 8080<br><br><span class="hljs-comment"># 就绪检查</span><br>readinessProbe:<br>  tcpSocket:<br>    port: 8080<br><br><span class="hljs-comment"># 负载均衡</span><br>service:<br>  <span class="hljs-comment"># ClusterIP/LoadBalancer/NodePort</span><br>  <span class="hljs-built_in">type</span>: LoadBalancer<br>  port: 80<br>  targetPort: 8080<br>  internalNetEnabled: <span class="hljs-literal">false</span><br><br>pvcs:<br>  - name: probe-test<br>    storage: 10Gi<br>    <span class="hljs-comment"># ReadWriteOnce/ReadOnlyMany/ReadWriteMany</span><br>    accessModes:<br>      - ReadWriteMany<br>    volumeMounts:<br>      - name: log1<br>        mountPath: /data/logs1<br>        subPath: <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h3 id="启动脚本">启动脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment">#处理参数，规范化参数</span><br><br>ARGS=`getopt -o i:r:d -l app-name:,release-version:,namespace:,dry-run,<span class="hljs-built_in">wait</span>,<span class="hljs-built_in">timeout</span>:,<span class="hljs-built_in">set</span>: -- $*`<br><br><span class="hljs-keyword">if</span> [ $? -ne 0 ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Usage: ...&#x27;</span><br>  <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><span class="hljs-comment">#重新排列参数顺序</span><br><span class="hljs-built_in">set</span> -- <span class="hljs-variable">$&#123;ARGS&#125;</span><br><span class="hljs-comment">#通过shift和while循环处理参数</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;ARGS&#125;</span><br><span class="hljs-keyword">while</span> :<br><span class="hljs-keyword">do</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-keyword">in</span><br>  -i)<br>    APP_IMAGE=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$2</span> | <span class="hljs-built_in">tr</span> -d <span class="hljs-string">&quot;&#x27;&quot;</span>)<br>    <span class="hljs-built_in">shift</span> 2<br>    ;;<br>  -r)<br>    RELEASE_VERSION=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$2</span> | <span class="hljs-built_in">tr</span> -d <span class="hljs-string">&quot;&#x27;&quot;</span>)<br>    <span class="hljs-built_in">shift</span> 2<br>    ;;<br>  -d)<br>    DEBUG_ENABLE=<span class="hljs-literal">true</span><br>    <span class="hljs-built_in">shift</span> 1<br>    ;;<br>  --dry-run)<br>    COMMAND_OPT=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMAND_OPT&#125;</span> <span class="hljs-variable">$1</span>&quot;</span><br>    <span class="hljs-built_in">shift</span> 1<br>    ;;<br>  --<span class="hljs-built_in">set</span>)<br>    COMMAND_OPT=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMAND_OPT&#125;</span> <span class="hljs-variable">$1</span> <span class="hljs-variable">$2</span>&quot;</span><br>    <span class="hljs-built_in">shift</span> 1<br>    ;;<br>  --<span class="hljs-built_in">wait</span>)<br>    COMMAND_OPT=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMAND_OPT&#125;</span> <span class="hljs-variable">$1</span>&quot;</span><br>    <span class="hljs-built_in">shift</span> 1<br>    ;;<br>  --<span class="hljs-built_in">timeout</span>)<br>    COMMAND_OPT=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMAND_OPT&#125;</span> <span class="hljs-variable">$1</span> <span class="hljs-variable">$2</span>&quot;</span><br>    <span class="hljs-built_in">shift</span> 2<br>    ;;<br>  --atomic)<br>    COMMAND_OPT=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;COMMAND_OPT&#125;</span> <span class="hljs-variable">$1</span>&quot;</span><br>    <span class="hljs-built_in">shift</span> 1<br>    ;;<br>  --)<br>    <span class="hljs-built_in">shift</span><br>    <span class="hljs-built_in">break</span><br>    ;;<br>  *)<br>    <span class="hljs-built_in">shift</span><br>    ;;<br>  <span class="hljs-keyword">esac</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">readonly</span> APP_NAME=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$1</span> | <span class="hljs-built_in">tr</span> -d <span class="hljs-string">&quot;&#x27;&quot;</span>)<br><span class="hljs-built_in">readonly</span> NAMESPACE=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$2</span> | <span class="hljs-built_in">tr</span> -d <span class="hljs-string">&quot;&#x27;&quot;</span>)<br><br><span class="hljs-keyword">if</span> [ ! <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;APP_NAME&#125;</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;APP_NAME must not be null&quot;</span><br>  <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;RELEASE_VERSION&#125;</span>&quot;</span> ] &amp;&amp; [ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;APP_IMAGE&#125;</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-r 版本迭代、-i 镜像 不能同时传递&quot;</span><br>  <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-keyword">if</span> [ ! <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;NAMESPACE&#125;</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;NAMESPACE must not be null&quot;</span><br>  <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">readonly</span> IMAGE_PREFIX=<span class="hljs-string">&quot;www.xxx.mirrors&quot;</span><br><span class="hljs-built_in">readonly</span> PROJECT_DIR=$(<span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(dirname <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>&quot;</span>)</span>/../..&quot;</span> || <span class="hljs-built_in">exit</span> 1; <span class="hljs-built_in">pwd</span>)<br><span class="hljs-built_in">readonly</span> HELM_DIR=<span class="hljs-variable">$&#123;PROJECT_DIR&#125;</span>/helm<br><span class="hljs-built_in">readonly</span> RELEASE_DIR=<span class="hljs-variable">$&#123;PROJECT_DIR&#125;</span>/releases/<span class="hljs-variable">$&#123;RELEASE_VERSION&#125;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">valuesPrase</span></span>() &#123;<br>  <span class="hljs-built_in">local</span> filepath=<span class="hljs-variable">$1</span><br>  <span class="hljs-built_in">local</span> local_type=$(<span class="hljs-built_in">dirname</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;filepath&#125;</span>&quot;</span> | <span class="hljs-built_in">cut</span> -d <span class="hljs-string">&#x27;/&#x27;</span> -f 2)<br><br>  <span class="hljs-built_in">local</span> local_app_name=$(<span class="hljs-built_in">basename</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;filepath&#125;</span>&quot;</span> | <span class="hljs-built_in">cut</span> -d <span class="hljs-string">&#x27;.&#x27;</span> -f 1)<br>  <span class="hljs-keyword">for</span> image <span class="hljs-keyword">in</span> $(<span class="hljs-built_in">cat</span> <span class="hljs-variable">$&#123;RELEASE_DIR&#125;</span>/images/java_images.txt <span class="hljs-variable">$&#123;RELEASE_DIR&#125;</span>/images/other_images.txt); <span class="hljs-keyword">do</span><br>    temp_app_name=$(<span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;image&#125;</span> | <span class="hljs-built_in">cut</span> -d <span class="hljs-string">&#x27;:&#x27;</span> -f 1)<br>    <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;local_app_name&#125;</span>&quot;</span> == <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;temp_app_name&#125;</span>&quot;</span> ]]; <span class="hljs-keyword">then</span><br>      helmUpgrade <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;local_app_name&#125;</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;image&#125;</span>&quot;</span><br>      <span class="hljs-built_in">break</span><br>    <span class="hljs-keyword">fi</span><br>  <span class="hljs-keyword">done</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">helmUpgrade</span></span>() &#123;<br>  <span class="hljs-built_in">local</span> local_app_name=<span class="hljs-variable">$1</span><br>  <span class="hljs-built_in">local</span> local_image=<span class="hljs-variable">$2</span><br><br>  <span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HELM_DIR&#125;</span>/conf/values&quot;</span> || <span class="hljs-built_in">exit</span> 1<br>  <span class="hljs-built_in">local</span> local_filepath=$(find . -<span class="hljs-built_in">type</span> f -maxdepth 2 -mindepth 2 -name <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;local_app_name&#125;</span>.yaml&quot;</span>)<br>  [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;local_filepath&#125;</span>&quot;</span> ] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;local_app_name&#125;</span> not found&quot;</span> &amp;&amp; <span class="hljs-built_in">exit</span> 1<br>  <span class="hljs-built_in">local</span> local_type=$(<span class="hljs-built_in">dirname</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;local_filepath&#125;</span>&quot;</span> | <span class="hljs-built_in">cut</span> -d <span class="hljs-string">&#x27;/&#x27;</span> -f 2)<br><br>  <span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HELM_DIR&#125;</span>&quot;</span> || <span class="hljs-built_in">exit</span> 1<br><br>  HELM_COMMAND=<span class="hljs-string">&quot;helm secrets upgrade --install&quot;</span><br>  <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;DEBUG_ENABLE&#125;</span>&quot;</span> = <span class="hljs-literal">true</span> ]]; <span class="hljs-keyword">then</span><br>    HELM_COMMAND=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HELM_COMMAND&#125;</span> --debug&quot;</span><br>  <span class="hljs-keyword">fi</span><br>  HELM_COMMAND=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HELM_COMMAND&#125;</span> -n <span class="hljs-variable">$&#123;NAMESPACE&#125;</span>&quot;</span><br>  HELM_COMMAND=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HELM_COMMAND&#125;</span> -f ./conf/values/common.yaml&quot;</span><br>  HELM_COMMAND=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HELM_COMMAND&#125;</span> -f ./conf/values/<span class="hljs-variable">$&#123;local_type&#125;</span>/<span class="hljs-variable">$&#123;local_app_name&#125;</span>.yaml&quot;</span><br>  <span class="hljs-built_in">local</span> secret_file=<span class="hljs-string">&quot;./conf/secrets/secrets.<span class="hljs-variable">$&#123;local_app_name&#125;</span>.yaml&quot;</span><br>  <span class="hljs-keyword">if</span> [[ -f <span class="hljs-string">&quot;<span class="hljs-variable">$secret_file</span>&quot;</span> ]]; <span class="hljs-keyword">then</span><br>    HELM_COMMAND=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HELM_COMMAND&#125;</span> -f <span class="hljs-variable">$&#123;secret_file&#125;</span>&quot;</span><br>  <span class="hljs-keyword">fi</span><br>  HELM_COMMAND=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HELM_COMMAND&#125;</span> <span class="hljs-variable">$&#123;local_app_name&#125;</span> ./chart-tpl&quot;</span><br>  HELM_COMMAND=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HELM_COMMAND&#125;</span> --set image.address=<span class="hljs-variable">$&#123;IMAGE_PREFIX&#125;</span>/<span class="hljs-variable">$&#123;local_image&#125;</span>&quot;</span><br>  HELM_COMMAND=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HELM_COMMAND&#125;</span> <span class="hljs-variable">$&#123;COMMAND_OPT&#125;</span>&quot;</span><br><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HELM_COMMAND&#125;</span>&quot;</span><br>  <span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HELM_COMMAND&#125;</span>&quot;</span><br>&#125;<br><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;APP_IMAGE&#125;</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-comment"># 指定镜像启动</span><br>  helmUpgrade <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;APP_NAME&#125;</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;APP_IMAGE&#125;</span>&quot;</span><br><span class="hljs-keyword">elif</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;RELEASE_VERSION&#125;</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;HELM_DIR&#125;</span>/conf/values&quot;</span> || <span class="hljs-built_in">exit</span> 1<br>  <span class="hljs-comment"># 指定迭代启动</span><br>  <span class="hljs-keyword">if</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;APP_NAME&#125;</span>&quot;</span>  =~ <span class="hljs-string">&quot;-&quot;</span> ]]; <span class="hljs-keyword">then</span><br>    filepath=$(find . -<span class="hljs-built_in">type</span> f -maxdepth 2 -mindepth 2 -name <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;APP_NAME&#125;</span>.yaml&quot;</span>)<br>    [ -z <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;filepath&#125;</span>&quot;</span> ] &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;APP_NAME&#125;</span> not found&quot;</span> &amp;&amp; <span class="hljs-built_in">exit</span> 1<br>    valuesPrase <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;filepath&#125;</span>&quot;</span><br>  <span class="hljs-keyword">elif</span> [[ <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;APP_NAME&#125;</span>&quot;</span>  == <span class="hljs-string">&quot;all&quot;</span> ]]; <span class="hljs-keyword">then</span><br>    filepaths=$(find . -<span class="hljs-built_in">type</span> f -maxdepth 2 -mindepth 2 -name <span class="hljs-string">&quot;*.yaml&quot;</span>)<br>    <span class="hljs-keyword">for</span> filepath <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;filepaths&#125;</span><br>    <span class="hljs-keyword">do</span><br>      valuesPrase <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;filepath&#125;</span>&quot;</span><br>    <span class="hljs-keyword">done</span><br>  <span class="hljs-keyword">else</span><br>    filepaths=$(find <span class="hljs-string">&quot;./<span class="hljs-variable">$&#123;APP_NAME&#125;</span>&quot;</span> -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&quot;*.yaml&quot;</span>)<br>    <span class="hljs-keyword">for</span> filepath <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;filepaths&#125;</span><br>    <span class="hljs-keyword">do</span><br>      valuesPrase <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;filepath&#125;</span>&quot;</span><br>    <span class="hljs-keyword">done</span><br>  <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">else</span><br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;-r 版本迭代、-i 镜像 至少需要一个&quot;</span><br>  <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h3 id="启动命令">启动命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 指定 image 启动</span><br>./helm.sh probe-busybox namespace -i probe-busybox:2302022222<br><br><span class="hljs-comment"># 指定-r迭代启动</span><br><span class="hljs-comment"># 启动单个服务</span><br>./helm.sh probe-busybox namespace -r 230202<br><span class="hljs-comment"># 按类型批量启动服务</span><br>./helm.sh infra namespace -r 230202<br><span class="hljs-comment"># 批量启动所有服务</span><br>./helm.sh all namespace -r 230202<br><br><span class="hljs-comment"># 设置 环境变量</span><br>./helm.sh probe-busybox namespace -r 230202 --<span class="hljs-built_in">set</span> env.ENV=PRO --<span class="hljs-built_in">set</span> env.CLUSTER=a<br><span class="hljs-comment"># 或</span><br>./helm.sh probe-busybox namespace -r 230202 --<span class="hljs-built_in">set</span> env.ENV=PRO,env.CLUSTER=a<br></code></pre></td></tr></table></figure><h2 id="加密">加密</h2><p>由于上述配置是要通过git做版本控制的，实际应用中存在一些环境变量，如密码等不能明文提交到git上，这里使用了helm secrets插件实现加密后提交到git，并在 helm 安装的渲染时解密</p><h3 id="安装">安装</h3><h4 id="helm-secret"><code>helm-secret</code></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm plugin install &lt;https://github.com/futuresimple/helm-secrets&gt;<br><span class="hljs-comment"># 查看</span><br>helm plugin list<br></code></pre></td></tr></table></figure><p>helm-secrets 插件本身并没有任何加密与解密的能力，而它所有的工作，都是通过调用 SOPS 命令来帮助它完成的。</p><p>SOPS 是由 Mozilla 开发的一款开源的文本编辑工具，它支持对 YAML, JSON, ENV, INI 和 BINARY 文本格式的文件进行编辑，并利用 AWS KMS, GCP KMS, Azure Key Vault 或 PGP 等加密方式对编辑的文件进行加密和解密。</p><p>helm-secrets 插件会自动检测并安装 sops 命令到我们的系统中，<code>sops -v</code> 查看。</p><h4 id="GPG">GPG</h4><p>GPG，全名 GNU Privacy Guard，是隶属于 GNU 项目下的一款开源免费的加密工具。目前绝大部分 Linux 发行版本都默认安装了 GPG</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ubuntu，Debian 用户</span><br>$ sudo apt install gnupg<br><br><span class="hljs-comment"># CentOS，Fedora，RHEL 用户</span><br>$ sudo yum install gnupg<br><br><span class="hljs-comment"># MacOS 用户</span><br>$ brew install gnupg<br><br>gpg --version<br></code></pre></td></tr></table></figure><h3 id="生成-GPG-密钥对">生成 GPG 密钥对</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --gen-key<br></code></pre></td></tr></table></figure><p>列出当前系统中的公钥和私钥信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --list-key<br>gpg --list-secret-keys<br></code></pre></td></tr></table></figure><p>设置秘钥配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 通过环境变量设置秘钥信息</span><br><span class="hljs-built_in">export</span> SOPS_PGP_FP=xxx<br><span class="hljs-comment"># 通过配置文件设置秘钥信息</span><br><span class="hljs-comment"># 每当执行 SOPS 命令时，它都会在当前目录下查找名为 .sops.yaml 的文件作为它的配置文件</span><br>creation_rules:<br>    - pgp: <span class="hljs-string">&quot;13D525EEF0A5FA38F4E78F7900E0160999E3C663&quot;</span><br><span class="hljs-comment"># 删除 PGP 密钥对</span><br>$ gpg --delete-secret-key xxx<br>$ gpg --delete-key xxx<br></code></pre></td></tr></table></figure><h3 id="加解密">加解密</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 加密</span><br>helm secrets enc secrets.probe-busybox.yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 加密前</span><br><span class="hljs-built_in">env</span>:<br>  password: <span class="hljs-built_in">test</span><br><span class="hljs-comment"># 加密后</span><br><span class="hljs-built_in">env</span>:<br>  password:  ENC[AES256_GCM,data:jo8lGGOFZuDY,iv:5Wwt/T0SskFxgWXNRjpoIPq+PIuTGILGIeN/dYOJ/Fg=,tag:ncC3t67xArsXvwwEjAGyLg==,<span class="hljs-built_in">type</span>:str]<br><br>sops:<br>    kms: []<br>    gcp_kms: []<br>    azure_kv: []<br>    lastmodified: <span class="hljs-string">&#x27;2020-04-24T03:48:37Z&#x27;</span><br>    mac: ENC[AES256_GCM,data:uFdXa2qWDSYqaeVsOLZiQos5K611uZYW91ZhLT00MJRb32TxE190RlJjhvl8+/GUOClZcIaU8DejebDP1TVqVFl6wpFqjVM3TLwW0JDm+b+zpCzMje9e17dNjLp7W2awBTPmrF3AXUopLi8oHOuopW89q2gKgFIUW215zjmQET0=,iv:A85xzE6gEXpcwUE6rIvHwHNhqmaCmFOHoYX3Y4qjaGI=,tag:VSB9b9vKLRJg4/klwliJbQ==,<span class="hljs-built_in">type</span>:str]<br>    pgp:<br>    -   created_at: <span class="hljs-string">&#x27;2020-04-24T03:48:35Z&#x27;</span><br>        enc: |<br>            -----BEGIN PGP MESSAGE-----<br><br>            hQIMA8ebLzL57hqOAQ//fOzjkY5tW1/fGd/HWrxsgC02YxAjmHggI2ek5VacdhYP<br>            A9RUYhpipJpBt1LnwHq/B1rV1E4dkOu1lpyAmI9P0qIc+6o0+6jEhqEyjsDQSGn5<br>            kh31oBNYfLq8XpHQg33jOIHpv6/BU7tqzsVMum3HjvnsSrhc3gRtBq5LZoLP/smA<br>            3y36tRLHIGFGqOEwy3CdSiPmsyCKQBEYRK0+7mhXX+ulEMudYXKgXk4qCL1UAB0y<br>            X03K0UATNYp8fRkHqzcpf5nLDNzpCGI0BNbxBQYZdbcP3KFNyKGDFtDaNCcJq9jv<br>            d6yMnioNWYBCtDlrZXlQGzipheWKwZ7JnNa1nmYpCJ3uh6I3mbtkHjljD88QUm6Y<br>            czGAsTDYESJPl5y2wdKdMxHOyE++Ii5LvNr2UD3D+ePYvAIpK1TWjfokCe18ZvvD<br>            v4kHbqbJfffpLCmy0CRVFu/yLnGdZGqniPY/UPPRk28cnKF+fxpX7EmLvzCUgadC<br>            4emIrR6nBUgGvU+fInZrNOccRhYU2S4So45CW2EXW5E4uNj8ayfUgtaUeRwW8pRE<br>            ZMGe1yna7a8UC0syiubC1rr8KHKs8nITfRrelV/BtEkfFDI9sm77AMcaWaAaaBz8<br>            C1L3A1iPhnclDnt3USqOTioLnZs9CjysyNSeiTvehsTC1E3GqgmVbUGob+0Im2fS<br>            XgHaA9fXLtulXkRQGFYpaNEt6r0mkgdq0DXCCfba6EflHg9BvPfrK0dtXrchlCY/<br>            K154U0LkPNHtLBXB0rNwz0Z9aA1CwBdRZ6r8V67SJS1nbsiIvyHfc4dq8n3qhVM=<br>            =HOrp<br>            -----END PGP MESSAGE-----<br>        fp: 00E0160999E3C663<br>    unencrypted_suffix: _unencrypted<br>    version: 3.5.0<br></code></pre></td></tr></table></figure><p>查看解密内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm secrets view secrets.probe-busybox.yaml<br></code></pre></td></tr></table></figure><p>解密后的内容将被存储到新创建的 <code>secrets.probe-busybox.yaml.dec</code> 文件中去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">helm secrets dec secrets.probe-busybox.yaml<br></code></pre></td></tr></table></figure><h2 id="服务依赖">服务依赖</h2><p>服务中存在依赖关系，因此需要等待前一个依赖的服务部署完成后才能部署后一个服务，比如需要先部署apollo再部署业务服务。</p><p>然而不行的是 包括docker-compose 、kubectl 、helm 在内都没有类似的功能。</p><ul><li><p>docker-compose 的 depends_on 也只是会先启动依赖的服务，再启动自己，并不会等到依赖的服务部署完成。</p></li><li><p>而 k8s 中更没有和 depends_on 类似的语句，我们可以通过entrypoint、initContainer 或者 就绪探针 写一段shell脚本一直循环运行，直到检测到依赖服务都启动完毕才退出，并启动自身容器。但太重了，不符合上面k8s理念。</p></li><li><p>helm dependencies 只是管理依赖并依据依赖创建pod，按照类型和名称排序并启动（详见上一篇helm 依赖顺序），还不如 docker-compose。</p></li></ul><blockquote><p>Kubernetes云原生的理念要求任何应用应该是“独立的”，应用自身是可以处理未连接或者重连接的情况，而不是交由Kuberntest集群层面来做，因为对于k8s来说，Pod或者Container是随时会被调度/重起的，k8s自身会检测所有的pod里的容器并确保它们活着并给他们贴上Healthy的标签，所以应该是尽量独立解耦的，不应该依赖其他服务才可以启动。</p></blockquote><h2 id="总结">总结</h2><p>考虑到第一次部署时，肯定要等到所有服务部署完毕，才会放流量，因此服务启动顺序并不很重要，只要保证最终服务都正常即可。</p><p>服务升级部署时，由于是滚动更新，当新pod就绪检查通过后，旧pod才会销毁，也可以保证服务不会因此中断，只需支持启动失败时自动回滚即可。</p><p>因此服务应尽量独立解耦，服务间存在依赖也不会有明显问题，helm 部署脚本不指定服务启动顺序。</p><p>所有 values 中的值均可用 --set 覆盖，在可以使用命令行一键部署的情况下，还可以为后面 Saas 平台管理数据部署提供扩展。</p><h2 id="参考">参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://helm.sh/docs/">https://helm.sh/docs/</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://polarsquad.com/blog/check-your-helm-deployments">https://polarsquad.com/blog/check-your-helm-deployments</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://kubernetes.io/zh-cn/docs/concepts/">https://kubernetes.io/zh-cn/docs/concepts/</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><a href="https://segmentfault.com/a/1190000040199249?utm_source=tag-newest">https://segmentfault.com/a/1190000040199249?utm_source=tag-newest</a><a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
      <tag>Helm</tag>
      
      <tag>K8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Helm 介绍</title>
    <link href="/posts/015-helm-Introduction.html"/>
    <url>/posts/015-helm-Introduction.html</url>
    
    <content type="html"><![CDATA[<p>工作需要批量部署同一套ToB（to business）服务到多个k8s cluster/namespace 上，经过几百根头发的研究，本文介绍Helm相关概念。</p><span id="more"></span><h2 id="简介">简介</h2><p>Helm 是 Kubernetes 包管理器，类似 Mac 下的 brew，Linux 下的 apt、yum 等包管理工具。</p><p>Helm 是 <a href="https://cncf.io/">CNCF</a> 的毕业项目，是查找、分享和使用软件构建 Kubernetes 的最优方式（Helm官方说的）。</p><blockquote><p>Helm is the best way to find, share, and use software built for Kubernetes.</p></blockquote><h2 id="基本概念">基本概念</h2><ul><li><p>Chart 代表着 Helm 包。它包含在 Kubernetes 集群内部运行应用程序，工具或服务所需的所有资源定义。你可以把它看作是 Homebrew formula，Apt dpkg，或 Yum RPM 在Kubernetes 中的等价物。</p></li><li><p>Repository（仓库） 是用来存放和共享 charts 的地方。（非必须，本文以本地 charts 文件为例，不使用Repository）</p></li><li><p>Release 是运行在 Kubernetes 集群中的 chart 的实例。一个 chart 通常可以在同一个集群中安装多次。每一次安装都会创建一个新的 release。以 MySQL chart为例，如果你想在你的集群中运行两个数据库，你可以安装该chart两次。每一个数据库都会拥有它自己的 release 和 release name。</p></li></ul><blockquote><p>Helm 安装 charts 到 Kubernetes 集群中，每次安装都会创建一个新的 release。你可以在 Helm 的 chart repositories 中寻找新的 chart。</p></blockquote><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/202303140108797.webp" alt="helm3"></p><h2 id="安装">安装</h2><h3 id="前置条件">前置条件</h3><ol><li><p>一个 Kubernetes 集群</p></li><li><p>确定你安装版本</p><p>查看Helm和对应支持的Kubernetes版本，您可以参考 <a href="https://helm.sh/zh/docs/topics/version_skew/">Helm 版本支持策略</a>。</p></li><li><p>安装和配置Helm。</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># mac os</span><br><span class="hljs-comment"># 安装 kubectl</span><br>brew install kubectl<br>brew install kubectx<br><span class="hljs-comment"># 安装 helm</span><br>brew install helm<br><br><span class="hljs-comment"># 查看</span><br>helm version<br></code></pre></td></tr></table></figure><h2 id="Chart-模板指南">Chart 模板指南</h2><h3 id="创建chart">创建chart</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个名为`mychart`的chart</span><br>helm create mychart<br></code></pre></td></tr></table></figure><h3 id="目录结构">目录结构</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 目录结构</span><br><span class="hljs-string">mychart/</span><br>  <span class="hljs-string">Chart.yaml</span>          <span class="hljs-comment"># 包含了chart信息的YAML文件</span><br>  <span class="hljs-string">LICENSE</span>             <span class="hljs-comment"># 可选: 包含chart许可证的纯文本文件</span><br>  <span class="hljs-string">README.md</span>           <span class="hljs-comment"># 可选: 可读的README文件</span><br>  <span class="hljs-string">values.yaml</span>         <span class="hljs-comment"># chart 默认的配置值</span><br>  <span class="hljs-string">values.schema.json</span>  <span class="hljs-comment"># 可选: 一个使用JSON结构的values.yaml文件</span><br>  <span class="hljs-string">charts/</span>             <span class="hljs-comment"># 可选: 包含chart依赖的其他chart</span><br>  <span class="hljs-string">crds/</span>               <span class="hljs-comment"># 可选: 自定义资源的定义</span><br>  <span class="hljs-string">templates/</span>          <span class="hljs-comment"># 模板目录， 当和values 结合时，可生成有效的Kubernetes manifest文件</span><br>    <span class="hljs-string">deployment.yaml</span>   <span class="hljs-comment"># 创建Kubernetes 工作负载的基本清单</span><br>    <span class="hljs-string">service.yaml</span>       <span class="hljs-comment"># 为你的工作负载创建一个 service终端基本清单。</span><br>    <span class="hljs-string">_helpers.tpl</span>       <span class="hljs-comment"># 放置可以通过chart复用的模板辅助对象</span><br>    <span class="hljs-string">NOTES.txt</span>         <span class="hljs-comment"># chart的&quot;帮助文本&quot;。这会在你的用户执行helm install时展示给他们。</span><br></code></pre></td></tr></table></figure><ul><li><p><code>values.yaml</code> 文件也导入到了模板。这个文件包含了chart的 <em>默认值</em> 。这些值会在用户执行<code>helm install</code> 或 <code>helm upgrade</code>时被覆盖。</p></li><li><p><code>Chart.yaml</code> 文件包含了该chart的描述。你可以从模板中访问它。<code>charts/</code>目录 <em>可以</em> 包含其他的chart(称之为 <em>子chart</em>)。</p></li><li><p><code>templates/</code> 目录包括了模板文件。当Helm评估chart时，会通过模板渲染引擎将所有文件发送到<code>templates/</code>目录中。 然后收集模板的结果并发送给Kubernetes。</p><ul><li><p><code>NOTES.txt</code>: chart的&quot;帮助文本&quot;。这会在你的用户执行<code>helm install</code>时展示给他们。</p></li><li><p><code>deployment.yaml</code>: 创建Kubernetes <a href="https://kubernetes.io/docs/user-guide/deployments/">工作负载</a>的基本清单</p></li><li><p><code>service.yaml</code>: 为你的工作负载创建一个 <a href="https://kubernetes.io/docs/user-guide/services/">service终端</a>基本清单。</p></li><li><p><code>_helpers.tpl</code>: 放置可以通过chart复用的模板辅助对象</p></li></ul></li></ul><h3 id="Chart-yaml">Chart.yaml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">chart</span> <span class="hljs-string">API</span> <span class="hljs-string">版本</span> <span class="hljs-string">（必需）</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">chart名称</span> <span class="hljs-string">（必需）</span><br><span class="hljs-attr">version:</span> <span class="hljs-string">语义化2</span> <span class="hljs-string">版本（必需）</span><br><span class="hljs-attr">kubeVersion:</span> <span class="hljs-string">兼容Kubernetes版本的语义化版本（可选）</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">一句话对这个项目的描述（可选）</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">chart类型</span> <span class="hljs-string">（可选）</span><br><span class="hljs-attr">keywords:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">关于项目的一组关键字（可选）</span><br><span class="hljs-attr">home:</span> <span class="hljs-string">项目home页面的URL</span> <span class="hljs-string">（可选）</span><br><span class="hljs-attr">sources:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">项目源码的URL列表（可选）</span><br><span class="hljs-attr">dependencies:</span> <span class="hljs-comment"># chart 必要条件列表 （可选）</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">chart名称</span> <span class="hljs-string">(nginx)</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">chart版本</span> <span class="hljs-string">(&quot;1.2.3&quot;)</span><br>    <span class="hljs-attr">repository:</span> <span class="hljs-string">（可选）仓库URL</span> <span class="hljs-string">(&quot;https://example.com/charts&quot;)</span> <span class="hljs-string">或别名</span> <span class="hljs-string">(&quot;@repo-name&quot;)</span><br>    <span class="hljs-attr">condition:</span> <span class="hljs-string">（可选）</span> <span class="hljs-string">解析为布尔值的yaml路径，用于启用/禁用chart</span> <span class="hljs-string">(e.g.</span> <span class="hljs-string">subchart1.enabled</span> <span class="hljs-string">)</span><br>    <span class="hljs-attr">tags:</span> <span class="hljs-comment"># （可选）</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">用于一次启用/禁用</span> <span class="hljs-string">一组chart的tag</span><br>    <span class="hljs-attr">import-values:</span> <span class="hljs-comment"># （可选）</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ImportValue</span> <span class="hljs-string">保存源值到导入父键的映射。每项可以是字符串或者一对子/父列表项</span><br>    <span class="hljs-attr">alias:</span> <span class="hljs-string">（可选）</span> <span class="hljs-string">chart中使用的别名。当你要多次添加相同的chart时会很有用</span><br><span class="hljs-attr">maintainers:</span> <span class="hljs-comment"># （可选）</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">维护者名字</span> <span class="hljs-string">（每个维护者都需要）</span><br>    <span class="hljs-attr">email:</span> <span class="hljs-string">维护者邮箱</span> <span class="hljs-string">（每个维护者可选）</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">维护者URL</span> <span class="hljs-string">（每个维护者可选）</span><br><span class="hljs-attr">icon:</span> <span class="hljs-string">用做icon的SVG或PNG图片URL</span> <span class="hljs-string">（可选）</span><br><span class="hljs-attr">appVersion:</span> <span class="hljs-string">包含的应用版本（可选）。不需要是语义化，建议使用引号</span><br><span class="hljs-attr">deprecated:</span> <span class="hljs-string">不被推荐的chart</span> <span class="hljs-string">（可选，布尔值）</span><br><span class="hljs-attr">annotations:</span><br>  <span class="hljs-attr">example:</span> <span class="hljs-string">按名称输入的批注列表</span> <span class="hljs-string">（可选）.</span><br></code></pre></td></tr></table></figure><h4 id="dependencies">dependencies</h4><p>当前chart依赖的其他chart会在<code>dependencies</code>字段定义为一个列表。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dependencies:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">apache</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-number">1.2</span><span class="hljs-number">.3</span><br>    <span class="hljs-attr">repository:</span> <span class="hljs-string">https://example.com/charts</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-number">3.2</span><span class="hljs-number">.1</span><br>    <span class="hljs-attr">repository:</span> <span class="hljs-string">https://another.example.com/charts</span><br></code></pre></td></tr></table></figure><p>一旦你定义好了依赖，运行 <code>helm dependency update</code> 就会使用你的依赖文件下载所有你指定的chart到你的<code>charts/</code>目录</p><p>当 <code>helm dependency update</code> 拉取chart时，会在<code>charts/</code>目录中形成一个chart包。因此对于上面的示例，会在chart目录中期望看到以下文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">charts/</span><br>  <span class="hljs-string">apache-1.2.3.tgz</span><br>  <span class="hljs-string">mysql-3.2.1.tgz</span><br></code></pre></td></tr></table></figure><h3 id="依赖顺序">依赖顺序</h3><p>上面的部分说明如何指定chart的依赖，但是对使用 <code>helm install</code> 和 <code>helm upgrade</code> 安装chart有什么影响？</p><p>假设有个chart “A” 创建了下面的Kubernetes对象：</p><ul><li>namespace “A-Namespace”</li><li>statefulset “A-StatefulSet”</li><li>service “A-Service”</li></ul><p>另外，A是依赖于chart B创建的对象：</p><ul><li>namespace “B-Namespace”</li><li>replicaset “B-ReplicaSet”</li><li>service “B-Service”</li></ul><p>安装/升级chart A后，会创建/修改一个单独的Helm版本。这个版本会按顺序创建/升级以下所有的Kubernetes对象：</p><ul><li>A-Namespace</li><li>B-Namespace</li><li>A-Service</li><li>B-Service</li><li>B-ReplicaSet</li><li>A-StatefulSet</li></ul><p>这是因为当Helm安装/升级chart时，chart中所有的Kubernetes对象以及依赖会</p><ul><li>聚合成一个单一的集合；然后</li><li>按照类型和名称排序；然后</li><li>按这个顺序创建/升级。</li></ul><p>至此会为chart及其依赖创建一个包含所有对象的release版本。</p><p>Kubernetes类型的安装顺序会按照kind_sorter.go(查看 <a href="https://github.com/helm/helm/blob/484d43913f97292648c867b56768775a55e4bba6/pkg/releaseutil/kind_sorter.go">Helm源文件</a>)中给出的枚举顺序进行。</p><h3 id="内置对象">内置对象</h3><ul><li><p><code>Release</code>： <code>Release</code>对象描述了版本发布本身，如 <code>Release.Name</code>： release名称</p></li><li><p><code>Values</code>： <code>Values</code>对象是从<code>values.yaml</code>文件和用户提供的文件传进模板的。默认为空</p></li><li><p><code>Chart</code>： <code>Chart.yaml</code>文件内容，比如 <code>&#123;&#123; .Chart.Name &#125;&#125;-&#123;&#123; .Chart.Version &#125;&#125;</code> 会打印出 <code>mychart-0.1.0</code></p></li><li><p><code>Files</code>： 在chart中提供访问所有的非特殊文件的对象。 请查看这个 <a href="https://helm.sh/zh/docs/chart_template_guide/accessing_files">文件访问</a>部分了解更多信息</p></li><li><p><code>Capabilities</code>： 提供关于Kubernetes集群支持功能的信息</p></li><li><p><code>Template</code>： 包含当前被执行的当前模板信息</p><p>请在<a href="https://helm.sh/zh/docs/chart_template_guide/builtin_objects/">内置对象</a>中查看更多</p></li></ul><h3 id="Values-文件">Values 文件</h3><p>Values内容来自于多个位置：</p><ul><li>chart中的<code>values.yaml</code>文件</li><li>如果是子chart，就是父chart中的<code>values.yaml</code>文件</li><li>使用<code>-f</code>参数(<code>helm install -f myvals.yaml ./mychart</code>)传递到 <code>helm install</code> 或 <code>helm upgrade</code>的values文件</li><li>使用<code>--set</code> (比如<code>helm install --set foo=bar ./mychart</code>)传递的单个参数</li></ul><p>以上列表有明确顺序：默认使用<code>values.yaml</code>，可以被父chart的<code>values.yaml</code>覆盖，继而被用户提供values文件覆盖， 最后会被<code>--set</code>参数覆盖，优先级为<code>values.yaml</code>最低，<code>--set</code>参数最高。</p><h3 id="Templates-and-Values">Templates and Values</h3><p>所有模板文件存储在chart的 <code>templates/</code> 文件夹。 当Helm渲染chart时，它会通过模板引擎遍历目录中的每个文件。</p><p>模板的Value通过两种方式提供：</p><ul><li>Chart开发者可以在chart中提供一个命名为 <code>values.yaml</code> 的文件。这个文件包含了默认值。</li><li>Chart用户可以提供一个包含了value的YAML文件。可以在命令行使用 <code>helm install -f demo.yaml </code>命令时提供。</li></ul><p>当用户提供自定义value时，这些value会覆盖chart的<code>values.yaml</code>文件中value。</p><h3 id="模板函数">模板函数</h3><p><a href="https://helm.sh/zh/docs/chart_template_guide/function_list/">模板函数列表</a></p><p>开始之前，我们先在<code>values.yaml</code>文件添加一个披萨的配料列表：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">favorite:</span><br>  <span class="hljs-attr">drink:</span> <span class="hljs-string">coffee</span><br>  <span class="hljs-attr">food:</span> <span class="hljs-string">pizza</span><br><span class="hljs-attr">pizzaToppings:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">mushrooms</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">cheese</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">peppers</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">onions</span><br></code></pre></td></tr></table></figure><h4 id="语法">语法</h4><p>模板函数的语法是 <code>functionName arg1 arg2...</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 示例  quote 双引号</span><br><span class="hljs-attr">drink:</span> &#123;&#123; <span class="hljs-string">quote</span> <span class="hljs-string">.Values.favorite.drink</span> &#125;&#125;<br><span class="hljs-comment"># 渲染结果</span><br><span class="hljs-attr">drink:</span> <span class="hljs-string">&quot;coffee&quot;</span><br></code></pre></td></tr></table></figure><h4 id="管道符">管道符</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 示例  quote 双引号</span><br><span class="hljs-attr">drink:</span> &#123;&#123; <span class="hljs-string">.Values.favorite.drink</span> <span class="hljs-string">|</span> <span class="hljs-string">quote</span> &#125;&#125;<br><span class="hljs-comment"># 渲染结果</span><br><span class="hljs-attr">drink:</span> <span class="hljs-string">&quot;coffee&quot;</span><br></code></pre></td></tr></table></figure><h3 id="流控制">流控制</h3><h4 id="If-Else">If/Else</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;&#123; <span class="hljs-string">if</span> <span class="hljs-string">PIPELINE</span> &#125;&#125;<br>  <span class="hljs-comment"># Do something</span><br>&#123;&#123; <span class="hljs-string">else</span> <span class="hljs-string">if</span> <span class="hljs-string">OTHER</span> <span class="hljs-string">PIPELINE</span> &#125;&#125;<br>  <span class="hljs-comment"># Do something else</span><br>&#123;&#123; <span class="hljs-string">else</span> &#125;&#125;<br>  <span class="hljs-comment"># Default case</span><br>&#123;&#123; <span class="hljs-string">end</span> &#125;&#125;<br></code></pre></td></tr></table></figure><p>PIPELINE 如果是以下值时，管道会被设置为 <em>false</em>：</p><ul><li>布尔false</li><li>数字0</li><li>空字符串</li><li><code>nil</code> (空或null)</li><li>空集合(<code>map</code>, <code>slice</code>, <code>tuple</code>, <code>dict</code>, <code>array</code>)</li></ul><p>在所有其他条件下，条件都为true。</p><h4 id="with">with</h4><p>with 用来控制变量范围</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;&#123; <span class="hljs-string">with</span> <span class="hljs-string">PIPELINE</span> &#125;&#125;<br>  <span class="hljs-comment"># restricted scope</span><br>&#123;&#123; <span class="hljs-string">end</span> &#125;&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>.</code>是对 <em>当前作用域</em> 的引用。因此 <code>.Values</code>就是告诉模板在当前作用域查找<code>Values</code>对象。<code>with</code>允许你为特定对象设定当前作用域(<code>.</code>)。</p></li><li><p><code>with</code>后面的块只有在 <code>PIPELINE</code> 的值不为空时才会执行。</p></li><li><p>在<code>with</code>的作用域内，无法使用<code>.</code>访问父作用域的对象，可以使用<code>$</code>从根作用域中访问对象或使用变量</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 修改配置映射中的`.`的作用域指向`.Values.favorite`：</span><br>&#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">with</span> <span class="hljs-string">.Values.favorite</span> &#125;&#125;<br><span class="hljs-attr">drink:</span> &#123;&#123; <span class="hljs-string">.drink</span> <span class="hljs-string">|</span> <span class="hljs-string">default</span> <span class="hljs-string">&quot;tea&quot;</span> <span class="hljs-string">|</span> <span class="hljs-string">quote</span> &#125;&#125;<br><span class="hljs-attr">food:</span> &#123;&#123; <span class="hljs-string">.food</span> <span class="hljs-string">|</span> <span class="hljs-string">upper</span> <span class="hljs-string">|</span> <span class="hljs-string">quote</span> &#125;&#125;<br><span class="hljs-attr">release:</span> &#123;&#123; <span class="hljs-string">$.Release.Name</span> &#125;&#125;<br>&#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> &#125;&#125;<br><br><span class="hljs-comment"># 渲染结果</span><br><span class="hljs-attr">drink:</span> <span class="hljs-string">&quot;coffee&quot;</span><br><span class="hljs-attr">food:</span> <span class="hljs-string">&quot;PIZZA&quot;</span><br><span class="hljs-attr">release:</span> <span class="hljs-string">mychart</span><br></code></pre></td></tr></table></figure><h4 id="range-循环">range 循环</h4><ul><li>在<code>range</code>的作用域内，无法使用<code>.</code>访问父作用域的对象，可以使用<code>$</code>从根作用域中访问对象或使用变量</li><li><code>range</code>可被用于迭代列表和元组以及有键值对的集合（像<code>map</code>或<code>dict</code>）</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">toppings:</span><br>  &#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">range</span> <span class="hljs-string">.Values.pizzaToppings</span> &#125;&#125;<br>  <span class="hljs-bullet">-</span> &#123;&#123; <span class="hljs-string">.</span> <span class="hljs-string">|</span> <span class="hljs-string">title</span> <span class="hljs-string">|</span> <span class="hljs-string">quote</span> &#125;&#125;<br>  &#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> &#125;&#125;  <br><span class="hljs-comment"># 渲染结果</span><br><span class="hljs-attr">toppings:</span> <br>  <span class="hljs-bullet">-</span> <span class="hljs-string">small</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">medium</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">large</span>  <br></code></pre></td></tr></table></figure><h4 id="变量">变量</h4><p>变量是对另一个对象的命名引用。遵循<code>$name</code>变量的格式且指定了一个特殊的赋值运算符：<code>:=</code>。</p><ul><li><p>用于解决with、range作用域问题</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 把.Release.Name 赋值给 $relname</span><br>&#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">$relname</span> <span class="hljs-string">:=</span> <span class="hljs-string">.Release.Name</span> <span class="hljs-string">-</span>&#125;&#125;<br>&#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">with</span> <span class="hljs-string">.Values.favorite</span> &#125;&#125;<br><span class="hljs-attr">drink:</span> &#123;&#123; <span class="hljs-string">.drink</span> <span class="hljs-string">|</span> <span class="hljs-string">default</span> <span class="hljs-string">&quot;tea&quot;</span> <span class="hljs-string">|</span> <span class="hljs-string">quote</span> &#125;&#125;<br><span class="hljs-attr">food:</span> &#123;&#123; <span class="hljs-string">.food</span> <span class="hljs-string">|</span> <span class="hljs-string">upper</span> <span class="hljs-string">|</span> <span class="hljs-string">quote</span> &#125;&#125;<br><span class="hljs-attr">release:</span> &#123;&#123; <span class="hljs-string">$relname</span> &#125;&#125;<br>&#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> &#125;&#125;<br></code></pre></td></tr></table></figure></li><li><p>变量还可以用于类似列表的对象，以捕获索引和值</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">range</span> <span class="hljs-string">$index</span>, <span class="hljs-string">$topping</span> <span class="hljs-string">:=</span> <span class="hljs-string">.Values.pizzaToppings</span> &#125;&#125;<br>  &#123;&#123; <span class="hljs-string">$index</span> &#125;&#125;<span class="hljs-string">:</span> &#123;&#123; <span class="hljs-string">$topping</span> &#125;&#125;<br>&#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> &#125;&#125;  <br></code></pre></td></tr></table></figure></li><li><p>变量还可以用于对于数据结构有key和value，可以使用<code>range</code>获取key和value。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">range</span> <span class="hljs-string">$key</span>, <span class="hljs-string">$val</span> <span class="hljs-string">:=</span> <span class="hljs-string">.Values.favorite</span> &#125;&#125;<br>  &#123;&#123; <span class="hljs-string">$key</span> &#125;&#125;<span class="hljs-string">:</span> &#123;&#123; <span class="hljs-string">$val</span> <span class="hljs-string">|</span> <span class="hljs-string">quote</span> &#125;&#125;<br>&#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> &#125;&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="空格">空格</h4><p>你可能注意到在上面的流控制中存在 <code>&#123;&#123;-` `-&#125;&#125;</code> 是为了消除流控制空格即换行，YAML认为空格是有意义的。</p><blockquote><p>一定注意空格就是换行</p></blockquote><ul><li><code>&#123;&#123;- `(包括添加的横杠和空格)表示向左删除空白， 而- ` -&#125;&#125;</code>表示右边的空格应该被去掉。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 示例1</span><br><span class="hljs-attr">food:</span> <span class="hljs-string">&quot;orange&quot;</span> <br>&#123;&#123; <span class="hljs-string">if</span> <span class="hljs-string">eq</span> <span class="hljs-string">.Values.favorite.drink</span> <span class="hljs-string">&quot;coffee&quot;</span> &#125;&#125;<br><span class="hljs-attr">mug:</span> <span class="hljs-string">&quot;true&quot;</span><br>&#123;&#123; <span class="hljs-string">end</span> &#125;&#125;<br><span class="hljs-comment"># 渲染结果</span><br><span class="hljs-attr">food:</span> <span class="hljs-string">&quot;orange&quot;</span> <br><br><span class="hljs-attr">mug:</span> <span class="hljs-string">&quot;true&quot;</span><br><br><span class="hljs-comment"># 示例2</span><br><span class="hljs-attr">food:</span> <span class="hljs-string">&quot;orange&quot;</span> <br>&#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">if</span> <span class="hljs-string">eq</span> <span class="hljs-string">.Values.favorite.drink</span> <span class="hljs-string">&quot;coffee&quot;</span> &#125;&#125;<br><span class="hljs-attr">mug:</span> <span class="hljs-string">&quot;true&quot;</span><br>&#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> &#125;&#125;<br><span class="hljs-comment"># 渲染结果</span><br><span class="hljs-attr">food:</span> <span class="hljs-string">&quot;orange&quot;</span> <br><span class="hljs-attr">mug:</span> <span class="hljs-string">&quot;true&quot;</span><br></code></pre></td></tr></table></figure><p>在上面示例中 1未加- food，mug后各有一行空格，因此一般流控制中都会加<code>&#123;&#123;- if xxx -&#125;&#125;</code>来确保没有空格/换行。</p><h3 id="命名模板">命名模板</h3><ul><li>以下划线(<code>_</code>)开始的文件不会渲染为Kubernetes对象定义，但会被helm命令加载。</li><li><code>_helpers.tpl</code>这个文件是默认的模板文件。</li></ul><h4 id="define使用模板"><code>define</code>使用模板</h4><p><code>define</code>操作允许我们在模板文件中创建一个命名模板</p><p>我们可以定义一个模板：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;&#123;<span class="hljs-string">/*</span> <span class="hljs-string">Generate</span> <span class="hljs-string">basic</span> <span class="hljs-string">labels</span> <span class="hljs-string">*/</span>&#125;&#125;<br>&#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">define</span> <span class="hljs-string">&quot;mychart.app&quot;</span> <span class="hljs-string">-</span>&#125;&#125;<br><span class="hljs-attr">app_name:</span> &#123;&#123; <span class="hljs-string">.Chart.Name</span> &#125;&#125;<br><span class="hljs-attr">app_version:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; .Chart.Version &#125;&#125;</span>&quot;</span><br>&#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">end</span> <span class="hljs-string">-</span>&#125;&#125;<br></code></pre></td></tr></table></figure><h4 id="template和include使用模板"><code>template</code>和<code>include</code>使用模板</h4><p>在configMap使用模板标签</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> &#123;&#123; <span class="hljs-string">.Release.Name</span> &#125;&#125;<span class="hljs-string">-configmap</span><br>  &#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">template</span> <span class="hljs-string">&quot;mychart.labels&quot;</span> &#125;&#125;<br>  &#123;&#123;<span class="hljs-bullet">-</span> <span class="hljs-string">include</span> <span class="hljs-string">&quot;mychart.labels&quot;</span> <span class="hljs-string">|</span> <span class="hljs-string">indent</span> <span class="hljs-number">4</span> &#125;&#125;<br><span class="hljs-comment"># 渲染结果</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ConfigMap</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">measly-whippet-configmap</span><br>  <span class="hljs-attr">labels:</span><br>  <span class="hljs-comment"># template</span><br>    <span class="hljs-attr">app_name:</span> <span class="hljs-string">mychart</span><br><span class="hljs-attr">app_version:</span> <span class="hljs-string">&quot;0.1.0&quot;</span><br>  <span class="hljs-comment"># include</span><br>    <span class="hljs-attr">app_name:</span> <span class="hljs-string">mychart</span><br>    <span class="hljs-attr">app_version:</span> <span class="hljs-string">&quot;0.1.0&quot;</span><br></code></pre></td></tr></table></figure><p>注意两处的<code>app_version</code>缩进都不对，为啥？因为被替换的模板中文本是左对齐的。由于<code>template</code>是一个行为，不是方法，无法将 <code>template</code>调用的输出传给其他方法，数据只是简单地按行插入。而indent 可以使用管道进行缩进。</p><blockquote><p>相较于使用<code>template</code>，在helm中使用<code>include</code>被认为是更好的方式 为了更好地处理YAML文档的输出格式</p></blockquote><h3 id="Chart-Hook">Chart Hook</h3><p>Helm 提供了一个 <em>hook</em> 机制允许chart开发者在发布生命周期的某些点进行干预。</p><table><thead><tr><th style="text-align:left">注释值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>pre-install</code></td><td style="text-align:left">在模板渲染之后，Kubernetes资源创建之前执行</td></tr><tr><td style="text-align:left"><code>post-install</code></td><td style="text-align:left">在所有资源加载到Kubernetes之后执行</td></tr><tr><td style="text-align:left"><code>pre-delete</code></td><td style="text-align:left">在Kubernetes删除之前，执行删除请求</td></tr><tr><td style="text-align:left"><code>post-delete</code></td><td style="text-align:left">在所有的版本资源删除之后执行删除请求</td></tr><tr><td style="text-align:left"><code>pre-upgrade</code></td><td style="text-align:left">在模板渲染之后，资源更新之前执行一个升级请求</td></tr><tr><td style="text-align:left"><code>post-upgrade</code></td><td style="text-align:left">所有资源升级之后执行一个升级请求</td></tr><tr><td style="text-align:left"><code>pre-rollback</code></td><td style="text-align:left">在模板渲染之后，资源回滚之前，执行一个回滚请求</td></tr><tr><td style="text-align:left"><code>post-rollback</code></td><td style="text-align:left">在所有资源被修改之后执行一个回滚请求</td></tr><tr><td style="text-align:left"><code>test</code></td><td style="text-align:left">调用Helm test子命令时执行 ( <a href="https://helm.sh/zh/docs/topics/chart_tests/">test文档</a>)</td></tr></tbody></table><h2 id="常用命令">常用命令</h2><ul><li><p><code>helm version</code> 打印客户端版本信息</p></li><li><p><code>helm upgrade --install</code> 升级/安装chart</p></li><li><p><code>helm rollback</code> - 回滚发布到上一个版本</p></li><li><p><code>helm lint</code> 是验证chart是否遵循最佳实践的首选工具。</p></li><li><p><code>helm template --debug</code> 在本地测试渲染chart模板。</p></li><li><p><code>helm install --dry-run --debug </code>：让服务器渲染模板，然后返回生成的清单文件。这样不会安装应用(chart)到你的kubenetes集群中，只会渲染模板内容到控制台（用于测试）</p></li><li><p><code>helm get manifest</code>: 这是查看安装在服务器上的模板。</p></li><li><p><a href="https://helm.sh/zh/docs/helm/helm/">更多命令</a></p></li></ul><h2 id="总结">总结</h2><ul><li><p>即使是最复杂的应用，Helm Chart 依然可以描述， 提供使用单点授权的可重复安装应用程序。</p></li><li><p>随时随地升级和自定义的钩子消除您升级的痛苦。</p></li><li><p>Helm Chart 很容易在公共或私有化服务器上发版，分发和部署站点。</p></li><li><p>使用 <code>helm rollback</code> 可以轻松回滚到之前的发布版本。</p></li></ul><h2 id="参考">参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://helm.sh/docs/">https://helm.sh/docs/</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://polarsquad.com/blog/check-your-helm-deployments">https://polarsquad.com/blog/check-your-helm-deployments</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://kubernetes.io/zh-cn/docs/concepts/">https://kubernetes.io/zh-cn/docs/concepts/</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
      <tag>Helm</tag>
      
      <tag>K8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 解析命令行参数</title>
    <link href="/posts/014-linux-command-params.html"/>
    <url>/posts/014-linux-command-params.html</url>
    
    <content type="html"><![CDATA[<p>最近需要写脚本封装 helm ,批量进行 k8s 服务的部署。需解析命令行参数场景较复杂。<br>本文列举各种解析Linux命令行参数三种方式优缺点，及使用限制。</p><span id="more"></span><p>Linux 解析命令行参数有三种方式</p><h2 id="直接处理">直接处理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#命令本身</span><br><span class="hljs-variable">$0</span>   <br><span class="hljs-comment">#第1、2、3...个参数，依次类推</span><br><span class="hljs-variable">$1</span>,<span class="hljs-variable">$2</span>,<span class="hljs-variable">$3</span>,<span class="hljs-variable">$4</span>...   <br><span class="hljs-comment">#参数的个数，不包括命令本身 </span><br><span class="hljs-variable">$#</span>   <br><span class="hljs-comment">#参数数组列表，不包括命令本身</span><br><span class="hljs-variable">$@</span>   <br><span class="hljs-comment">#和$@相同，但&quot;$*&quot;和&quot;$@&quot;(加引号)并不同，</span><br><span class="hljs-comment">#&quot;$*&quot;将所有的参数解释成一个字符串，而&quot;$@&quot;是一个参数数组</span><br>$*   <br></code></pre></td></tr></table></figure><h2 id="getopts">getopts</h2><p><code>getopts</code>是<code>bash</code>的内部命令</p><p>“getopts ‘:a:b:c:d:ef’”，识别选项字符串</p><ul><li>&quot;第一个<code>:</code>&quot;消除警告信息。如果命令行中包含了没有在getopts列表中的选项，会有警告信息，在整个getopts字符串前面加上<code>:</code>就可消除警告信息</li><li>&quot;字母后面<code>:</code>&quot;表示参数，一个冒号就表示这个选项后面必须带有参数，不带<code>:</code>表示不需要参数</li><li><code>a|b|c|d|e|f</code> 对应到命令行就是-a ,-b ,-c ,-d, -e ,-f。</li><li><code>OPTARG</code>，用来取当前选项的值，另外一个是</li><li><code>OPTIND</code>，代表当前选项在参数列表中的位移</li><li><code>?</code>，代表这如果出现了不认识的选项，所进行的操作。</li></ul><h3 id="示例">示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">getopts</span> <span class="hljs-string">&#x27;:a:b:c:d:ef&#x27;</span> OPT; <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-variable">$OPT</span> <span class="hljs-keyword">in</span><br>        a)<br>            <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$OPT</span> arg is <span class="hljs-variable">$OPTARG</span>&quot;</span><br>            ;;<br>        b|c|d)<br>            <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$OPT</span> arg is <span class="hljs-variable">$OPTARG</span>&quot;</span><br>            ;;<br>        e)<br>            <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$OPT</span> enabled&quot;</span><br>            ;;<br>        f)<br>            <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$OPT</span> enabled&quot;</span><br>            ;;<br>        ?)<br>            <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Usage: `basename <span class="hljs-variable">$0</span>` [options] filename&quot;</span><br>    <span class="hljs-keyword">esac</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-comment"># 选项参数识别完成之后，如果要取剩余的其它命令行参数，可以使用`shift`把选项参数抹去，位移的长度正好是刚才case循环完毕之后的OPTIND - 1。getopts在处理参数的时候，处理一个开关型选项，OPTIND加1，处理一个带值的选项参数，OPTIND则会加2。 </span><br><span class="hljs-built_in">shift</span> $((<span class="hljs-variable">$OPTIND</span> - <span class="hljs-number">1</span>))<br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 测试结果</span><br>➜  ./getopts.sh -a aaa -b bbb -c ccc -d ddd -e -f hello world<br>a arg is aaa<br>b arg is bbb<br>c arg is ccc<br>d arg is ddd<br>e enabled<br>f enabled<br>hello world<br></code></pre></td></tr></table></figure><h2 id="getopt">getopt</h2><p><code>getopt</code>是一个外部命令，但通常Linux发行版会自带</p><blockquote><p>注意：mac下的getopt由BSD实现，Linux则是gnu，不兼容（这里踩了很久的坑，为啥 mac 、Linux 总有一边报错-.-）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># mac安装gnu的getopt</span><br>brew install gnu-getopt<br><span class="hljs-comment"># 配置环境变量</span><br>brew <span class="hljs-built_in">link</span> --force gnu-getopt<br><br><span class="hljs-comment"># 强行 link 覆盖 mac 本身 getopt 有可能会导致系统不确定风险，可根据操作系统执行不同命令</span><br><span class="hljs-keyword">if</span> [[ `<span class="hljs-built_in">uname</span>` == <span class="hljs-string">&#x27;Darwin&#x27;</span> ]]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Mac OS&quot;</span><br>    GETOPT=`/usr/local/Cellar/gnu-getopt/2.38.1/bin/getopt`<br><span class="hljs-keyword">elif</span> [[ `<span class="hljs-built_in">uname</span>` == <span class="hljs-string">&#x27;Linux&#x27;</span> ]]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Linux&quot;</span><br>    GETOPT=`getopt`<br><span class="hljs-keyword">else</span><br> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;OS error&#x27;</span><br> <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"> getopt --<span class="hljs-built_in">help</span><br><br>用法：<br> getopt optstring parameters<br> getopt [options] [--] optstring parameters<br> getopt [options] -o|--options optstring [options] [--] parameters<br><br>选项：<br> -a, --alternative            允许长选项以 - 开始<br> -h, --<span class="hljs-built_in">help</span>                   这个简短的用法指南<br> -l, --longoptions &lt;长选项&gt;  要识别的长选项<br> -n, --name &lt;程序名&gt;         将错误报告给的程序名<br> -o, --options &lt;选项字符串&gt;  要识别的短选项<br> -q, --quiet                  禁止 getopt(3) 的错误报告<br> -Q, --quiet-output           无正常输出<br> -s, --bash &lt;bash&gt;          设置 bash 引用规则<br> -T, --<span class="hljs-built_in">test</span>                   测试 getopt(1) 版本<br> -u, --unquoted               不引用输出<br> -V, --version                输出版本信息<br><br></code></pre></td></tr></table></figure><ul><li>-o或–options选项后面是可接受的短选项，如ab:c::，表示可接受的短选项为-a -b -c，</li><li>-l或–long选项后面是可接受的长选项，用逗号分开，冒号的意义同短选项。</li><li><code>:</code>冒号表示参数，一个冒号就表示这个选项后面必须带有参数（没有带参数会报错），但是这个参数可以和选项连在一起写，也可以用空格隔开，比如-a123 和-a 123（中间有空格） 都表示123是-a的参数；</li><li>不带<code>:</code>表示不需要参数</li><li><code>::</code>表示这个选项的参数是可选的，即可以有参数，也可以没有参数，但要注意有参数时，参数与选项之间不能有空格（有空格会报错），这一点和一个冒号时是有区别的。</li><li>如果短选项带参数且参数可选时，参数必须紧贴选项，例如-carg而不能是-c arg</li><li>如果长选项带参数且参数可选时，参数和选项之间用“=”，例如–clong=arg而不能是–clong arg</li></ul><h3 id="示例-2">示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;传入参数:<span class="hljs-variable">$@</span>&quot;</span><br><br><span class="hljs-comment"># 需以getopt与传入参数--分隔</span><br>ARGS=`getopt -o ab:c:: --long along,blong:,clong:: -n <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>&quot;</span> -- <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span>`<br><span class="hljs-keyword">if</span> [ $? -ne 0 ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;getopt error ...&quot;</span><br>    <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><span class="hljs-comment"># 重新排列参数顺序</span><br><span class="hljs-built_in">set</span> -- <span class="hljs-variable">$&#123;ARGS&#125;</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;排列后参数:<span class="hljs-variable">$@</span>&quot;</span><br><br><span class="hljs-comment"># 通过shift和while循环处理参数</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-keyword">in</span><br>        -a|--along)<br>            <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span> is enabled&quot;</span>;<br>            <span class="hljs-built_in">shift</span><br>            ;;<br>        -b|--blong)<br>            <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span> arg is <span class="hljs-variable">$2</span>&quot;</span>;<br>            <span class="hljs-built_in">shift</span> 2<br>            ;;<br>        -c|--clong)<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;<span class="hljs-variable">$2</span>&quot;</span> <span class="hljs-keyword">in</span><br>                <span class="hljs-string">&quot;&quot;</span>)<br>                    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span> is enabled&quot;</span>;<br>                    <span class="hljs-built_in">shift</span> 2<br>                    ;;<br>                *)<br>                    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$1</span> arg is <span class="hljs-variable">$2</span>&quot;</span>;<br>                    <span class="hljs-built_in">shift</span> 2;<br>                    ;;<br>            <span class="hljs-keyword">esac</span><br>            ;;<br>        --)<br>            <span class="hljs-built_in">shift</span><br>            <span class="hljs-built_in">break</span><br>            ;;<br>        *)<br>            <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Internal error!&quot;</span><br>            <span class="hljs-built_in">exit</span> 1<br>            ;;<br>    <span class="hljs-keyword">esac</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-comment">#处理剩余的参数</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;剩余参数:<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 测试结果</span><br>➜ ./getopt.sh -a -b bbb -c -cccc hello world --along --blong bbb --clong=ccc --clong<br>传入参数:-a -b bbb -c -cccc hello world --along --blong bbb --clong=ccc --clong<br>排列后参数:-a -b <span class="hljs-string">&#x27;bbb&#x27;</span> -c <span class="hljs-string">&#x27;&#x27;</span> -c <span class="hljs-string">&#x27;ccc&#x27;</span> --along --blong <span class="hljs-string">&#x27;bbb&#x27;</span> --clong <span class="hljs-string">&#x27;ccc&#x27;</span> --clong <span class="hljs-string">&#x27;&#x27;</span> -- <span class="hljs-string">&#x27;hello&#x27;</span> <span class="hljs-string">&#x27;world&#x27;</span><br>-a is enabled<br>-b arg is <span class="hljs-string">&#x27;bbb&#x27;</span><br>-c arg is <span class="hljs-string">&#x27;&#x27;</span><br>-c arg is <span class="hljs-string">&#x27;ccc&#x27;</span><br>--along is enabled<br>--blong arg is <span class="hljs-string">&#x27;bbb&#x27;</span><br>--clong arg is <span class="hljs-string">&#x27;ccc&#x27;</span><br>--clong arg is <span class="hljs-string">&#x27;&#x27;</span><br>剩余参数:<span class="hljs-string">&#x27;hello&#x27;</span> <span class="hljs-string">&#x27;world&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="getopt-getopts-区别">getopt getopts 区别</h2><table><thead><tr><th></th><th>getopt</th><th>getopts</th></tr></thead><tbody><tr><td>支持短选项</td><td>✅</td><td>❌</td></tr><tr><td>支持长选项</td><td>✅</td><td>❌</td></tr><tr><td>支持可选参数</td><td>✅</td><td>❌</td></tr><tr><td>参数重排序</td><td>✅</td><td>❌</td></tr><tr><td>case</td><td>-a|–along)</td><td>a)</td></tr><tr><td>参数顺序</td><td>任意顺序</td><td>所有选项参数必须写在其它参数的前面</td></tr><tr><td></td><td>每处理完一个位置参数后都需要自己<code>shift</code>来跳到下一个位置</td><td>在最后使用 <code>shift $(($OPTIND - 1))</code>来跳到parameters的位置</td></tr><tr><td></td><td>外部命令,通常Linux发行版会自带</td><td>bash内部命令</td></tr></tbody></table><h2 id="总结">总结</h2><ul><li>简单脚本可以直接处理</li><li>大多数情况使用getopts</li><li>处理复杂场景使用getopt</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 使用 Crontab + Logrotate 实现日志分割</title>
    <link href="/posts/013-crontab-and-logrotate-log-clean.html"/>
    <url>/posts/013-crontab-and-logrotate-log-clean.html</url>
    
    <content type="html"><![CDATA[<p>由于业务需要 SkyWalking agent 上报的 segment 数据做分析，所以搭了一个 Nginx 集群来转发数据到业务端，但是由于流量很大 Nginx 日志经常被打满，导致 Nginx 挂掉，因此采用 Crontab + Logrotate 实现日志分割。</p><span id="more"></span><p>nginx 默认没有提供对日志文件的分割功能，所以随着时间的增长，access.log 和 error.log 文件会越来越大，尤其是 access.log，其日志记录量比较大，更容易增长文件大小，影响日志写入性能。</p><h2 id="Logrotate">Logrotate</h2><h3 id="安装">安装</h3><p>logrotate 是一个 Linux系统日志的管理工具。可以对单个日志文件或者某个目录下的文件按时间 / 大小进行切割，压缩操作；指定日志保存数量；还可以在切割之后运行自定义命令。</p><p>logrotate 是基于 crontab 运行的，所以这个时间点是由 crontab 控制的，具体可以查询 crontab 的配置文件 /etc/anacrontab。系统会按照计划的频率运行 logrotate，通常是每天。在大多数的 Linux 发行版本上，计划每天运行的脚本位于 /etc/cron.daily/logrotate。</p><p>主流 Linux 发行版上都默认安装有 logrotate 包，如果你的 Linux 系统中找不到 logrotate, 可以使用 apt-get 或 yum 命令来安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y logrotate<br></code></pre></td></tr></table></figure><p>一般 Linux 都已经自带 logrotate，下列命令可以查看是否已安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -ql logrotate<br></code></pre></td></tr></table></figure><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/20230129180900.png" alt="image-20230129180900416"></p><h3 id="基本用法">基本用法</h3><h4 id="主配置文件">主配置文件</h4><p><code>/etc/logrotate.conf</code> 这个文件是 logrotate 的主配置文件，定义了日志文件分割的通用参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># see &quot;man logrotate&quot; for details</span><br><span class="hljs-comment"># rotate log files weekly</span><br>weekly<br><br><span class="hljs-comment"># keep 4 weeks worth of backlogs</span><br>rotate 4<br><br><span class="hljs-comment"># create new (empty) log files after rotating old ones</span><br>create<br><br><span class="hljs-comment"># use date as a suffix of the rotated file</span><br>dateext<br><br><span class="hljs-comment"># uncomment this if you want your log files compressed</span><br><span class="hljs-comment">#compress</span><br><br><span class="hljs-comment"># RPM packages drop log rotation information into this directory</span><br><span class="hljs-comment"># 加载 /etc/logrotate.d 的所有自定义配置文件，自定义配置文件中的配置可以覆盖掉通用配置。</span><br>include /etc/logrotate.d<br><br><span class="hljs-comment"># no packages own wtmp and btmp -- we&#x27;ll rotate them here</span><br>/var/log/wtmp &#123;<br>    monthly<br>    create 0664 root utmp<br>        minsize 1M<br>    rotate 1<br>&#125;<br><br>/var/log/btmp &#123;<br>    missingok<br>    monthly<br>    create 0600 root utmp<br>    rotate 1<br>&#125;<br><br><span class="hljs-comment"># system-specific logs may be also be configured here.</span><br></code></pre></td></tr></table></figure><h4 id="自定义配置文件">自定义配置文件</h4><blockquote><p>自定义配置文件在<code>/etc/logrotate.d</code>目录下</p></blockquote><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/20230130104338.png" alt="image-20230130104338184"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 指定要对哪个路径的哪些文件进行分割</span><br>/data/nginx/logs/*.<span class="hljs-built_in">log</span> &#123;<br><span class="hljs-comment"># 按天切割。触发切割时如果时间不到一天不会执行切割。除了 daily，还可以选 hourly，monthly，weekly，yearly；</span><br>daily<br><br><span class="hljs-comment"># 用于还在打开中的日志文件，把当前日志备份并截断；是先拷贝再清空的方式，拷贝和清空之间有一个时间差，可能会丢失部分日志数据。</span><br>copytruncate<br><br><span class="hljs-comment"># 指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份</span><br>rotate 3<br><br><span class="hljs-comment"># 如果日志丢失，不报错继续滚动下一个日志</span><br>missingok<br><br><span class="hljs-comment"># 如果日志是空的就不轮替（也就是空日志不切割）</span><br>notifempty<br><br><span class="hljs-comment"># 当日志文件 &gt;= log-size 的时候就转储</span><br>size 1G<br>&#125;<br></code></pre></td></tr></table></figure><p>系统会在每天利用 cron 定时执行 logrotate 日志分割指令。这里我们为了看到效果，不等到系统自动执行，可以手动强制执行一次日志分割。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># -v:显示执行日志</span><br><span class="hljs-comment"># -f:强制执行分割</span><br>logrotate -vf <span class="hljs-regexp">/etc/</span>logrotate.d/nginx<br></code></pre></td></tr></table></figure><h4 id="日志分割步骤">日志分割步骤</h4><ol><li>默认分割后日志的命名为源日志名称 +. 序号（从 1 开始）。分割之前将所有之前分割出的日志文件重命名，序号往后移一位；</li><li>执行分割，将源日志文件分割为源日志文件名 .1。这样就保证了所有分割后的文件中，序号最小的是最新分割出的，序号最大的是最早分割出的；</li><li>根据 rotate 设置，如果此次分割后文件数量大于 rotate 设置，那么删除序号最大的那个分割文件，也就是最旧的分割日志。</li></ol><p>实际开发中可以使用 create 代替 copytruncate，它们的区别如下：</p><ul><li>copytruncate 先将源文件内容拷贝到分割后文件，再清空源文件，拷贝和清空之间有时间差，可能会丢失部分日志。另外拷贝操作在源文件比较大时消耗性能；</li><li>create 直接将源文件重命名为分割后文件，再创建一个与源文件名称相同的新文件，用于后续日志写入。</li></ul><p>但是要注意 create 即使创建新的文件后，如果没有主动通知应用程序，那么应用程序仍然会往旧的文件(即被重命名的那个分割后的文件)写入日志。所以此时在分割后要通知应用程序重新打开新的日志文件进行写入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>/var/log/nginx/*.<span class="hljs-built_in">log</span> &#123;<br>    daily                      <br>    rotate 30              <br>    create<br>    sharedscripts  <span class="hljs-comment"># 所有的文件切割之后只执行一次下面脚本，通知nginx重新打开新的日志文件进行后续写入</span><br>    postrotate<br>        <span class="hljs-keyword">if</span> [ -f /run/nginx.pid ]; <span class="hljs-keyword">then</span><br>            <span class="hljs-built_in">kill</span> -USR1 `<span class="hljs-built_in">cat</span> /run/nginx.pid`  <span class="hljs-comment"># 通过USER1信号通知nginx重新打开日志文件</span><br>        <span class="hljs-keyword">fi</span><br>    endscript<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>一般情况下如果应用程序提供了通知其打开新的日志文件的接口，那么推荐使用 create 续写日志；否则推荐使用 copytruncate 续写日志。</p></blockquote><p>注意：</p><ul><li>/etc/logrotate.d 中的自定义配置中，如果不配置 rotate、daily 等参数在强制手动执行时并不会继承默认的主配置 /etc/logrotate.conf。比如不配置 rotate 时，并不会继承保留 4 个分割文件，而是等价于 0，即不保留任何分割文件。所以自定义配置中推荐显式指定这些参数；</li><li>在系统crontab定时任务自动执行logrotate时，自定义配置会继承主配置文件中的参数；</li><li>logrotate 执行分割的时机要依赖于 crontab 定时任务，也就是说 crontab 定时任务每日触发时，logrotate 才会读取相应配置，检查是否满足分割的条件决定是否执行分割。这意味着，在默认 crontab 每日触发 logrotate 的定时任务情况下，即便 logrotate 配置文件中配置的分割频率小于1天，也将按照 1 天的频率触发分割，除非修改 crontab 定时任务，将 logrotate 的任务触发频率修改为小于 1 天。</li></ul><h4 id="分割文件压缩">分割文件压缩</h4><p>通过如下设置对分割后的日志文件压缩</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>/opt/logtest/*.<span class="hljs-built_in">log</span> &#123;<br>    daily<br>    rotate 2<br>    copytruncate<br>    missingok<br>    compress           <span class="hljs-comment"># 以gzip方式压缩</span><br>    nodelaycompress    <span class="hljs-comment"># 所有分割后的文件都进行压缩</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一般可以将 nodelaycompress 改为 delaycompress，这样分割后对最新的序号为1的文件不会进行压缩，对其他序号的文件进行压缩，这样可以方便我们查看最新的分割日志。</p><h4 id="按照时间分割">按照时间分割</h4><p>按照时间分割可以定时分割出一个日志，比如每天分割一次，配合其他参数可以完成保留最近 n 天日志的功能。以下配置可以实现每天分割一次日志，并且保留最近 30 天的分割日志。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">/opt/logtest/*.<span class="hljs-built_in">log</span> &#123;<br>    daily      <span class="hljs-comment"># 每天分割一次</span><br>    rotate 30  <span class="hljs-comment"># 保留最近30个分割后的日志文件</span><br>    copytruncate<br>    missingok<br>    dateext  <span class="hljs-comment"># 切割后的文件添加日期作为后缀</span><br>    dateyesterday <span class="hljs-comment"># 配合dateext使用，添加前一天的日期作为分割后日志的后缀</span><br>    dateformat -%Y-%m-%d  <span class="hljs-comment"># 格式为2022-02-08 默认添加的日期后缀格式为 yyyyMMdd，可以用 dateformat 自定义。</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="按照大小分割">按照大小分割</h4><p>我们可以利用 size 配置指定当日志文件达到多大体积时才进行分割。以下配置指定了每天执行分割，但是只有当日志文件大于 5M 时才真正执行分割操作。</p><p>注意：这个配置并不是说日志文件达到指定大小就自动执行分割，它还是要遵循定时任务。比如配置了daily只有到每天指定时间执行分割任务时，才会检查文件大小，对超过指定大小的文件进行分割。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">/opt/logtest/*.<span class="hljs-built_in">log</span> &#123;<br>    daily      <span class="hljs-comment"># 每天分割一次</span><br>    size 5M    <span class="hljs-comment"># 源文件小于5M时不分割</span><br>    rotate 30  <span class="hljs-comment"># 保留最近30个分割后的日志文件</span><br>    create<br>    missingok<br>    dateext  <span class="hljs-comment"># 切割后的文件添加日期作为后缀</span><br>    dateyesterday <span class="hljs-comment"># 配合dateext使用，添加前一天的日期作为分割后日志的后缀</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="每小时分割">每小时分割</h4><p>logrotate 实现每日定时执行日志分割的原理是通过 cron 定时任务，默认在 /etc/cron.daily 中包含 logrotate 可执行命令，所以系统每天会定时启动 logrotate，然后它会根据配置中具体分割频率（daily、weekly 等）以及其他条件（比如 size）决定是否要真正执行分割操作。</p><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/20230130111026.png" alt="image-20230130111026049"></p><p>如果我们想要实现每小时进行一次分割，需要如下步骤：</p><ol><li>logrotate 配置文件中指定分割频率为 hourly；</li><li>配置完以后，还需要在 cron 的每小时定时任务中加入 logrotate，因为默认情况下只有 /etc/cron.daily 中包含 logrotate 可执行命令，我们要将它往 /etc/cron.hourly 中也拷贝一份，这样系统才会每小时调用一次 logrotate 去执行分割。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> /etc/cron.daily/logrotate /etc/cron.hourly/<br></code></pre></td></tr></table></figure><h4 id="自定义分割">自定义分割</h4><p>实际业务中 Nginx 日志很快就打满了，因此需要自定义分割</p><ol><li><p>在非 /etc/logrotate.d 目录创建 logrotate 配置文件，这是为了避免被系统的定时任务扫描到该配置而导致重复执行分割。</p></li><li><p>添加 crontab 计划任务，3种方式</p></li><li><p>在 root 用户下执行 <code>crontab -e</code> 进入 vim 模式，进行编辑。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">crontab -e<br><span class="hljs-comment"># 5分钟进行一次日志切割</span><br>*/5 * * * * /usr/sbin/logrotate -v /etc/logrotate_mytime/nginx<br></code></pre></td></tr></table></figure></li><li><p>或者 在 <code>/var/spool/cron/</code> 下编辑，使用<code>crontab -e</code> 命令添加的任务，都是编写在该文件下。</p></li><li><p>直接执行 crontab 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">crontab */5 * * * * /usr/sbin/logrotate -v /etc/logrotate_mytime/nginx &gt;&gt; /dev/null 2&gt;&amp;1<br></code></pre></td></tr></table></figure><p>定时任务命令或需脚本结尾加 &amp;&gt;/dev/null 或 &gt;/dev/null 2&gt;&amp;1 或 1&gt;/dev/null 2&gt;/dev/null</p></li></ol><h4 id="遇到的问题">遇到的问题</h4><p>我们 Nginx 服务是以容器部署的，但发现自定义分割配置并未执行，发现要使用cron服务，先要安装vixie-cron软件包和crontabs软件包，我们 Linux 基础镜像是没有安装这个的。</p><p>vixie-cron软件包是cron的主程序。crontabs软件包是用来安装、卸装、或列举用来驱动 cron 守护进程的表格的程序。</p><p>安装命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install vixie-cron<br>yum install crontabs<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Log</tag>
      
      <tag>Linux</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 常用命令</title>
    <link href="/posts/012-linux-common-commands.html"/>
    <url>/posts/012-linux-common-commands.html</url>
    
    <content type="html"><![CDATA[<p>Linux 常用命令：能解决 95% 以上的问题</p><span id="more"></span><h2 id="Linux-文件系统">Linux 文件系统</h2><ul><li><code>/var</code>：包含在正常操作中被改变的文件、假脱机文件、记录文件、加锁文件、临时文件和页格式化文件等。</li><li><code>/home</code>：包含用户的文件：参数设置文件、个性化文件、文档、数据、EMALL、缓存数据等，每增加一个用户，系统就会根据其用户名在 home 目录下新建和其他用户同名的文件夹，用于保存其用户配置。</li><li><code>/proc</code>：包含虚幻的文件，他们实际上并不存在于磁盘上，也不占用任何空间（用 ls-l 可以显示它们的大小）当查看这些文件时，实际上是在访问存在内存中的信息，这些信息用于访问系统。</li><li><code>/bin</code>：包含系统启动时需要的执行文件（二进制），这些文件可以被普通用户使用。</li><li><code>/etc</code>：为操作系统的配置文件目录（防火墙、启动项）</li><li><code>/root</code>：为系统管理员（也叫超级用户或根用户）的 Home 目录。</li><li><code>/dev</code>：为设备目录，Linux 下设备被当成文件，这样一来硬件被抽象化、便于读写、网络共享以及需要临时装载到文件系统中，正常情况下，设备会有一个独立的子目录，这些设备的内容会出现在独立的子目录下。</li></ul><h2 id="Linux-命令操作">Linux 命令操作</h2><ul><li><p><strong>查看当前目录命令：<code>pwd</code></strong></p></li><li><p><strong>打开文件夹命令：<code>cd</code></strong></p></li><li><ul><li>打开指定文件夹：<code>cd [目录名称]</code></li><li>打开当前用户的根目录：<code>cd ~</code></li><li>返回上级目录：<code>cd …</code></li><li>返回进入目录：<code>cd -</code></li><li>打开根目录：<code>cd /</code></li></ul></li><li><p><strong>浏览目录下的文件列表命令：<code>ls</code></strong></p></li><li><ul><li>以列的方式查看当前目录下的文件列表：<code>ls -l</code></li><li>查看当前目录下所有的文件（包括隐藏文件）：<code>ls -a</code></li><li>以列表的方式查看当前目录下的所有文件：<code>ls -la</code></li></ul></li><li><p><strong>创建文件目录命令：<code>mkdir</code></strong></p></li><li><ul><li>新建文件目录：<code>mkdir 文件夹名称</code></li><li>递归新建多级目录：<code>mkdir -p 文件夹名称</code></li><li>例如在用户目录下新建 test 目录，命令这样写：<code>mkdir -p test/test1/test2/test3</code> 递归新建多级目录的写法</li></ul></li><li><p><strong>删除文件目录命令：<code>rmkdir</code></strong></p></li><li><ul><li>删除指定目录：<code>rmkdir 目录名称</code></li><li>递归删除指定目录及中间目录：<code>rmdir -p 目录名称</code> 这里没有写错，没有字母 k</li></ul></li><li><p><strong>删除文件或者目录命令：<code>rm</code></strong></p></li><li><ul><li>常用命令：<code>rm -rf [目录或文件]</code> <code>rm -ri [目录或文件]</code></li><li>强制删除文件或目录：<code>rm -rf 目录或者文件</code></li><li>在删除前询问是否确认删除：<code>rm -ri 目录或文件</code></li></ul></li></ul><blockquote><p>因为强制删除的后果不太好，一般不建议使用 <code>rm -rf</code> 进行文件删除</p><p>rm 命令中不跟 r 参数，无法删除目录，只能删除文件</p></blockquote><ul><li><p><strong>复制文件或目录命令：<code>cp</code></strong></p></li><li><ul><li>递归复制目录1下的所有的文件和文件夹到目录2：<code>cp -r [目录1][目录2]</code></li><li>执行复制操作时覆盖原有目录前询问用户：<code>cp -ri [目录1][目录2]</code></li></ul></li><li><p><strong>移动文件、修改文件名命令：<code>mv</code></strong></p></li><li><ul><li>将文件夹1名称更改为文件夹2：<code>mv 文件1 文件2</code> (给文件更名)</li><li>将目录1的文件移动到目录2：<code>mv 目录2 目录2</code> (将目录1的文件移动到目录2)</li></ul></li><li><p><strong>创建文件命令：<code>touch</code></strong></p></li><li><ul><li>touch 文件名称</li></ul></li><li><p><strong>查看、编辑文件命令：<code>vi</code></strong></p></li><li><ul><li><p>vi 命令为 UNIX 操作系统或者类 UNIX 操作系统都有具有的功能强大的文件编辑命令，用户输入 vi ++ 文件名，便可以进入 vi 模式进行文件内容的查看和编辑，如果文件已经存在，则直接打开文件，如果文件不存在，则系统将打开一个全新的空文件。</p></li><li><p>vi 的三种模式：</p><ol><li><p>命令模式</p><ul><li><p>当用户使用 vi 命令打开文件后，则进入命令模式，用户可以输入命令来执行各种功能。</p><table><thead><tr><th><strong>取值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>L</td><td>光标移至屏幕最后一行</td></tr><tr><td>space</td><td>光标右移一个字符</td></tr><tr><td>backspace</td><td>光标左移一个字符</td></tr><tr><td>N+</td><td>光标向上移动 N 行</td></tr><tr><td>n+</td><td>光标移下移 n 行</td></tr></tbody></table></li></ul></li><li><p>输入模式</p><ul><li><p>如果用户要对文件做修改，则可以使用下面几种命令，进入输入模式，用户进入输入模式之后，可以任意修改文件，除了 Esc 键外，用户输入的任何字符都会被作为内容写入文件中，用户输入 Esc 可以对文件进行相关操作。</p><table><thead><tr><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>a、i、r、o、A、I、R、O</td><td>编辑模式</td></tr><tr><td>dd</td><td>删除当前光标</td></tr><tr><td>ndd</td><td>删除 n 行</td></tr></tbody></table></li></ul></li><li><p>末行模式</p><ul><li><p>如果用户完成编辑命令，则可以按照 esc + “:” 进入末行模式，用户可以对文件内容继续进行搜索，也可以输入 “:wq!” 进行文件保存并退出，或者输入 “:q!” 强制退出文件编辑。</p><table><thead><tr><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>:wq!</td><td>保存并退出</td></tr><tr><td>:q!</td><td>强制退出</td></tr><tr><td>: s/字符串 1/字符串 2</td><td>将文件中出现的字符串 1 替换为字符串2</td></tr><tr><td>:set nu</td><td>显示所有行号</td></tr></tbody></table></li></ul></li></ol></li></ul></li><li><p><strong>查看、编辑文件命令：<code>cat</code></strong></p></li><li><ul><li>显示一个小的文件的内容：<code>cat 文件名称</code></li><li>创建并打开一个新的文件：<code>cat &gt; 文件名称</code></li></ul></li><li><p><strong>查看文件开头内容命令：<code>head</code></strong></p></li><li><ul><li><p><code>head [参数] [文件名]</code></p><ul><li><p>例如，使用 head 命令显示某个文件开始的 n 行数据：<code>head -n 文件名称</code></p><table><thead><tr><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>&lt; 行数 &gt; 显示的行数</td></tr><tr><td>默认</td><td>默认显示文件前 10 行数据</td></tr></tbody></table></li></ul></li></ul></li><li><p><strong>查看文件结尾内容命令：<code>tail</code></strong></p></li><li><ul><li>动态加载某个文件的内容（常用于查看日志文件）：<code>tail -f 文件名称</code></li><li>展示文件最后几行的数据：<code>tail -n 行数文件名称</code></li></ul></li></ul><h2 id="Linux-权限管理">Linux 权限管理</h2><h3 id="用户和用户组">用户和用户组</h3><p>用户是指在一个操作系统中，一系列权限的集合体，操作人员通过用户名和口令可以在系统中执行某一些被允许的操作。不同的用户可以具有不同的权限。Linux 操作系统中每个用户都具有唯一标识 UID，当使用命令创建用户时，如果不指定用户的 UID，则系统将自动为其分配 UID。</p><p>用户组就是具有相同特征的用户的集合体，在 Linux 系统中，每一个用户都属于至少一个用户组。Linux 操作系统中每个用户分组都具有唯一标识 GID，当使用命令创建用户组时，如果不指定用户组的 GID，则系统将自动为其分配 GID。当使用 -u 指定用户 id 时，用户 id 尽量大于500，以免冲突。因为 Linux 操作系统安装后，会默认建立一些用户，所以可能会占用 500 之内的 id 号。</p><p>Linux 权限机制有以下特点：</p><ul><li>系统有一个权限最大的用户，其名称为 root ，root 用户属于 root 用户组。</li><li>系统默认只有 root 权限可以添加和删除用户。</li><li>添加用户之后，如果没有给用户指定用户组，则系统会为用户添加一个同名的用户组，用户属于该组。</li><li>root 切换到普通用户无需登录，普通用户切换到 root 用户需要登陆。</li><li>root 可以给用户赋予和回收某一个文件的读、写、执行的权限。</li></ul><h3 id="用户操作命令">用户操作命令</h3><ul><li><p><strong>切换用户命令：<code>su</code></strong></p></li><li><ul><li><code>su [用户名]</code> 或者 <code>su -[用户名]</code></li><li><code>su[用户名]</code>和 <code>su -[用户名]</code>都可以切换用户，前者类似于临时切换用户，当使用该命令进行切换新用户时，用户配置仍然沿用原来的用户配置，如环境变量、系统变量等。而后者进行切换用户时，环境变量、系统设置全部切换成新用户的用户配置。</li></ul></li><li><p><strong>查看当前登陆用户命令：<code>whoami</code></strong></p></li><li><p><strong>查看当前用户所属分组命令：<code>groups</code></strong></p></li><li><p><strong>查看当前用户 UID 和 GID 命令：<code>id</code></strong></p></li><li><p><strong>添加新用户命令：<code>useradd</code></strong></p><ul><li><p>在 Linux 操作系统中添加用户：<code>useradd 用户名</code></p><p>在 Linux 操作系统中添加用户并指定用户 UID：<code>useradd -u</code> 指定的 UID 用户名</p></li></ul><table><thead><tr><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>代表 comment 指定一段注释性描述</td></tr><tr><td>-d</td><td>指定用户主目录</td></tr><tr><td>-g</td><td>指定用户所属的用户组</td></tr><tr><td>-G</td><td>指定用户所属的附加组</td></tr><tr><td>-u</td><td>指定用户的用户好</td></tr><tr><td>缺省</td><td>直接添加用户</td></tr></tbody></table></li><li><p><strong>修改用户密码命令：<code>passwd</code></strong></p><ul><li><p>例如：修改当前用户名为 sang 的用户密码：<code>passwd sang</code></p></li><li><p>在添加用户之后，只有为其设置密码，用户才能登陆</p><table><thead><tr><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>-d</td><td>删除密码。仅有系统管理员才能使用</td></tr><tr><td>-f</td><td>强制执行</td></tr><tr><td>-k</td><td>设置只有密码过期后才能更新</td></tr><tr><td>-l</td><td>锁着密码</td></tr><tr><td>-s</td><td>列出面膜的相关信息，仅有系统管理员才能使用</td></tr><tr><td>-u</td><td>解开已上锁的账号</td></tr></tbody></table></li></ul></li><li><p><strong>删除用户命令：<code>userdel</code></strong></p></li><li><ul><li><p>删除用户：<code>userdel 用户名</code></p></li><li><p>删除用户并同时删除其登陆信息：<code>userdel -r 用户名</code></p><table><thead><tr><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>-r</td><td>删除用户以及其登陆日志等信息</td></tr><tr><td>-f</td><td>强制删除用户，即使用户已经登陆</td></tr><tr><td>缺省</td><td>直接删除用户</td></tr></tbody></table></li></ul></li><li><p><strong>修改用户信息命令：<code>usermod</code></strong></p></li><li><ul><li><p>语法：<code>usermod [选项] [参数] [用户名]</code></p></li><li><p>修改用户登录名：<code>usermod -l 新用户名 旧用户名</code></p></li><li><p>修改用户所属分组：<code>usermod -g 新组名称 用户名</code></p><table><thead><tr><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>修改用户账号的备注文字</td></tr><tr><td>-d</td><td>修改用户登陆时的目录</td></tr><tr><td>-e</td><td>修改账号的有效期</td></tr><tr><td>-f</td><td>修改密码过期后多少天关闭账号</td></tr><tr><td>-g</td><td>修改用户所属的群组</td></tr><tr><td>-G</td><td>修改用户所属附加组</td></tr><tr><td>-l</td><td>修改用户账号名称</td></tr><tr><td>-L</td><td>锁定用户密码，使密码无效</td></tr><tr><td>-u</td><td>修改用户 id</td></tr><tr><td>-U</td><td>解除密码锁定</td></tr></tbody></table></li></ul></li><li><p><strong>添加用户组命令：<code>groupadd</code></strong></p></li><li><ul><li><p>语法：<code>groupadd [选项] [组名称]</code></p></li><li><p>修改用户登陆名：<code>groupadd 组名</code></p></li><li><p>修改用户所属分组：<code>groupadd -g 组 GID 组名</code></p><table><thead><tr><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>-g</td><td>指定工作组的 id</td></tr><tr><td>-r</td><td>创建系统工作组</td></tr><tr><td>-o</td><td>允许添加组 ID 不唯一的工作组</td></tr><tr><td>缺省</td><td>添加用户分组</td></tr></tbody></table></li></ul></li></ul><h3 id="权限操作">权限操作</h3><p>Linux 操作系统为文件定义了读、写、执行三种权限，不同的用户或者用户组可以具有不同的权限，系统采用 “r”、“w”、“x” 来分别表示文件的读、写、执行权限。使用 ls -l 命令可以查看到用户在当前目录或者文件的操作权限。</p><p>如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">drwxr</span> -xr -x. <span class="hljs-number">2</span> root root <span class="hljs-number">4096</span> Sep <span class="hljs-number">23</span> <span class="hljs-number">2011</span> bin<br></code></pre></td></tr></table></figure><p>从左至右分别表示如下含义：</p><ul><li><code>d</code>：代表 bin 数目目录而不是文件</li><li><code>rwx</code>：代表拥有者具有读、写、执行的权限</li><li><code>r -x</code>：代表同组用户具有读、执行的权限，但是没有写权限</li><li><code>r -x</code>：代表其他组用户具有读、执行权限，没有写权限</li></ul><h4 id="常用的变更权限命令为：chmod">常用的变更权限命令为：<code>chmod</code></h4><p>语法：<code>chmod [选项] [参数]</code></p><table><thead><tr><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>显示指令执行过程，但只返回更改的部分</td></tr><tr><td>-f</td><td>不显示错误信息</td></tr><tr><td>-r</td><td>递归授权</td></tr><tr><td>-v</td><td>显示指令执行过程</td></tr></tbody></table><p>chmod 的参数可以分为两种，分别是权限模式和数字模式。</p><p><strong>权限模式：</strong></p><p>权限模式使用 u、g、o 分别代表拥有者、同组用户、其他组用户，使用 + 和一代表赋予和收回权限，使用 r、w、x 代表读、写、执行权限。</p><p>例如：将文件01的执行权限给当前用户，写权限赋给用户所在的用户组和其他用户。</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tp">chmod -r U+<span class="hljs-keyword">X</span>,G+<span class="hljs-keyword">W</span> F<span class="hljs-number">01</span><br></code></pre></td></tr></table></figure><p>例如：将文件 f01 的读、写、执行的权限赋给当前用户，将读、写权限赋给用户所在的用户组和其他用户。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">chmod -r <span class="hljs-attribute">u</span>=rwx,g=rw,o=rw f01<br></code></pre></td></tr></table></figure><p><strong>数字模式：</strong></p><p>为了简化授权步骤，用户也可以采用数字模式进行授权，使用二进制的形式代表 r、w、x 三种权限，如 <code>101 (5) =r -x</code>，<code>111 (7) =rwx</code>，<code>100 (3) =r- -</code></p><p>例如：将文件 f01 的读、写、执行的权限赋给当前用户，将读和执行权限赋给用户组、将写和执行权限赋给其他用户。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">chmod</span> <span class="hljs-number">753</span> -r f01<br></code></pre></td></tr></table></figure><p>例如：将文件 f01 的读、写、执行权限赋给所有用户。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">chmod</span> <span class="hljs-number">777</span> -r f01<br></code></pre></td></tr></table></figure><h2 id="Linux-进程管理">Linux 进程管理</h2><p>在 Linux 的应用中，我们需要对进程进行管理，如查看某个进程是否启动、以及在必要的时刻，杀掉某个线程。</p><ul><li><strong>查看进程命令：ps</strong></li></ul><p>ps 命令是 Linux 操作系统中查看进程的命令，通过 ps 命令我们可以查看 Linux 操作系统中正在运行的过程，并可以获得进程的 PID（进程的唯一标识），通过 PID 可以对进程进行相应的管理。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -ef | <span class="hljs-keyword">grep</span> [进程关键字]<br></code></pre></td></tr></table></figure><p>根据进程关键词查看进程命令显示如下，显示的进程列表中第一列表示开启进程的用户，第二列表示进程唯一标识 PID，第三列表示父进程 PPID，第四列表示 CPU 占用资源比列，最后一列表示进程所执行程序的具体位置。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">[zheng@localhost ~]$ ps -ef|<span class="hljs-keyword">grep</span> sshd<br>root <span class="hljs-number">1829</span> <span class="hljs-number">1</span>  <span class="hljs-number">0</span> May2<span class="hljs-number">0</span> ?   <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> /usr/sbin/sshd<br>shang <span class="hljs-number">24166</span> <span class="hljs-number">24100</span>  <span class="hljs-number">0</span>   <span class="hljs-number">20</span>:<span class="hljs-number">17</span> pts/<span class="hljs-number">2</span>  <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>      <span class="hljs-keyword">grep</span>  sshd<br>[zheng@localhost ~]$<br></code></pre></td></tr></table></figure><ul><li><strong>杀掉进程命令：kill</strong></li></ul><p>当系统中有进程进入死循环，或者需要被关闭时，我们可以使用 kill 命令对其关闭。</p><p><code>kill -9 [PID]</code> PID 为 Linux 操作系统中进程的标识</p><h2 id="Linux-其他常用命令大全">Linux 其他常用命令大全</h2><ul><li>清屏命令：clear</li><li>查询命令详细参数命令：man</li><li>挂载命令：mnt</li><li>远程连接服务 SSH 相关命令：</li><li>启动 SSH 服务命令：<code>service sshd start</code></li><li>重启 SSH 服务命令：<code>service sshd restart</code></li><li>关闭 SSH 服务命令：<code>service sshd stop</code></li></ul><p>Linux 大多数情况下都是远程服务器，开发者通过远程工具连接 Linux ，启动了某个项目的 JAR，一旦窗口关闭，JAR 也就停止运行了，因此一般通过如下命令启动 JAR：<code>nohup java -jar jar-0.0.1-SNAPSHOT.jar &amp;</code></p><p>这里多了 nohup ，表示当前窗口关闭时服务不挂起，继续在后台运行</p><h2 id="Linux-系统软件安装">Linux 系统软件安装</h2><h3 id="常用软件安装">常用软件安装</h3><p>Linux 下常用的软件安装方式有3种。</p><ul><li><strong>tar 安装</strong>：如果开发商提供的是 tar、tar.gz、<a href="http://tar.bz">tar.bz</a> 格式的包（其中 tar 格式的为打包后没有压缩的包，gz 结尾的是按照 gzip 打包并压缩的软件包，<a href="http://tar.bz">tar.bz</a> 是按照二进制方式打包并压缩的软件包），可以采用 tar 包安装，tar 安装方式本质上是解压软件开发商提供的软件包，之后在通过相应配置，完成软件的安装。</li><li><strong>rpm 安装</strong>：rpm 安装方式是 redhat Linux 系列推出的一个软件包管理器，类似于 Windows 下的 exe 安装程序，可以直接使用 rpm 命令安装。</li><li><strong>yum 安装</strong>：yum 安装本质上依然是 rpm 包安装，和 rpm 安装方式的不同之处是用户可以通过 yum 参数，指定安装的软件包，系统将自动从互联网上下载相应的 rpm 软件包。而无须用户关心软件包的下载地址，以及软件包的依赖关系。</li></ul><h3 id="软件安装常用命令">软件安装常用命令</h3><ul><li><p>解压压缩命令：<code>tar</code></p><ul><li><p>语法：<code>tar [选项] [压缩包]</code></p></li><li><p>解压 gzip 包：<code>tar -zxvf [包名]</code></p></li><li><p>解压 bz 包：<code>tar -jxvf [包名]</code></p></li><li><p>解压普通包：<code>tar -xvf [包名]</code></p><table><thead><tr><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>指定特定目录压缩</td></tr><tr><td>-x</td><td>从备份文件中还原文件</td></tr><tr><td>-t</td><td>列出备份文件的内容</td></tr><tr><td>-r</td><td>添加文件到已经压缩的文件</td></tr><tr><td>-z</td><td>有 gzip 属性的（后缀是 gz 的）</td></tr><tr><td>-j</td><td>有 bz2 属性的（后缀是 bz 的）</td></tr><tr><td>-Z</td><td>有 cpmpress 属性的</td></tr><tr><td>-v</td><td>显示所有进程</td></tr><tr><td>-O</td><td>将文件解压到标准输出</td></tr><tr><td>-f</td><td>使用档案名称</td></tr></tbody></table></li></ul></li><li><p>安装卸载命令：<code>rpm</code></p><ul><li><p>语法：<code>rpm [选项] [软件包]</code></p></li><li><p>查询是否已经安装了某软件包：<code>rpm -qa|grep [软件包关键词]</code></p></li><li><p>卸载已经安装的软件包：<code>rpm -e 软件包全名</code></p></li><li><p>安装软件包并查看进度：<code>rpm -ivh 软件包路径</code></p><table><thead><tr><th>取值</th><th>说明</th></tr></thead><tbody><tr><td>-ivh</td><td>安装显示安装进度</td></tr><tr><td>-Uvh</td><td>升级软件包</td></tr><tr><td>-qpl</td><td>列出 rpm 软件包内的文件信息</td></tr><tr><td>-qpi</td><td>列出 rpm 软件包的描述信息</td></tr><tr><td>-qf</td><td>查找指定文件属于哪个 rpm 软件包</td></tr><tr><td>-Va</td><td>校验所有的 rpm 软件包，查找丢失的文件</td></tr><tr><td>-e</td><td>删除包</td></tr><tr><td>-qa</td><td>查找已经安装的 rpm 包</td></tr></tbody></table></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于 Skywalking 根因分析设计与实现</title>
    <link href="/posts/011-root-cause-analyze.html"/>
    <url>/posts/011-root-cause-analyze.html</url>
    
    <content type="html"><![CDATA[<p>微服务架构在独立部署、快速交付和灵活扩展上表现出极大的优势，但也会带来新的问题。服务间的调用关系变得异常复杂。当微服务架构出现系统性风险时，排查风险和故障诊断相比于传统的项目会更加困难。根因分析就是跟据服务和端点调用指标快速定位微服务应用问题的一种方法。</p><span id="more"></span><h2 id="要解决的问题">要解决的问题</h2><p>目前针对单台实例，我们已经有了灵犀诊断通过分析应用的堆、栈信息来快速分析实例问题，但随着微服务应用越来越多，服务间调用越来越复杂，如何快速定位到实例或者服务维度为题成为一个亟需解决的问题。</p><h2 id="概念">概念</h2><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/011-root-cause-analyze/20220830214836-20220901214609758.png" alt="image-20220830162456964"></p><p>根据上图可以了解到一个应用除了本地调用之外、还会有远程调用（DB、Redis、HTTP、MQ等），而HTTP、DUBBO远程调用又会关联到服务端应用，基于这样的关系，一个完整的微服务调用链路就可以串联起来，我们就可以根据这些关系去做根因分析。</p><p>为了解决实现根因分析，我们需要掌握以下一些概念：</p><h3 id="入口端点">入口端点</h3><p>一个业务服务处理事务入口成为入口端点</p><ul><li>HTTP/Dubbo</li><li>MQ 消费处理入口（包含Kafka，RocketMQ，RabbitMQ）</li><li>调度 Job 入口（调度系统，Spring Task，ScheduledThreadPoolExecutor等等）</li></ul><h3 id="出口端点">出口端点</h3><p>每个入口端点都包含本地操作（Local）以及远程操作，远程操作对应的即为出口端点</p><ul><li>HTTP / Dubbo 调用出口</li><li>MQ 消息发送出口（包含Kafka，RocketMQ，RabbitMQ）</li><li>数据库读写调用出口（包含MySQL， MongoDB，Redis，Elasticsearch，HBase等等）</li></ul><h3 id="指标">指标</h3><ul><li>应用所有入口端点的【耗时】和【成功率】</li><li>每个入口端点之后的每种操作的【耗时】和【成功率】</li></ul><h2 id="指标收集">指标收集</h2><h3 id="指标类型">指标类型</h3><p>基于skywalking上报的segment数据，我们可以很轻易的获取到上述入口端点、出口端点、Local的指标数据</p><p>简单抽象成如下几种类型：</p><table><thead><tr><th></th><th>指标名</th><th>labels</th></tr></thead><tbody><tr><td>入口</td><td>rca_entry_duration、rca_entry_error_rate</td><td>service：服务、entry：入口端点</td></tr><tr><td>Dubbo</td><td>rca_exit_dubbo_duration、rca_exit_dubbo_error_rate</td><td>entry: 入口端点、exit：出口端点</td></tr><tr><td>HTTP</td><td>rca_exit_http_duration、rca_exit_http_error_rate</td><td>entry: 入口端点、address：远程地址</td></tr><tr><td>MySQL</td><td>rca_exit_mysql_duration、rca_exit_mysql_error_rate</td><td>entry: 入口端点、address：远程地址</td></tr><tr><td>MongoDB</td><td>rca_exit_mongodb_duration、rca_exit_mongodb_error_rate</td><td>entry: 入口端点、address：远程地址</td></tr><tr><td>Hbase</td><td>rca_exit_hbase_duration、rca_exit_hbase_error_rate</td><td>entry: 入口端点、address：远程地址</td></tr><tr><td>Elasticsearch</td><td>rca_exit_es_duration、rca_exit_es_error_rate</td><td>entry: 入口端点、address：远程地址</td></tr><tr><td>RocketMQ</td><td>rca_exit_rocketmq_duration、rca_exit_rocketmq_error_rate</td><td>entry: 入口端点、address：远程地址</td></tr><tr><td>RabbitMQ</td><td>rca_exit_rabbitmq_duration、rca_exit_rabbitmq_error_rate</td><td>entry: 入口端点、address：远程地址</td></tr><tr><td>Kafka</td><td>rca_exit_kafka_duration、rca_exit_kafka_error_rate</td><td>entry: 入口端点、address：远程地址</td></tr></tbody></table><h3 id="端点格式调整">端点格式调整</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">com.qihoo.xxxFacade.xxxMethod --&gt; demo-app.xxxFacade.xxxMethod<br></code></pre></td></tr></table></figure><ul><li><p>通过端点即可知道是哪个服务，减少指标label</p></li><li><p>与CAT数据格式保持一致，方便后续与CAT打通</p></li></ul><h3 id="指标收集架构图">指标收集架构图</h3><p>由于要对skywalking数据二次处理，同时又要保证skywalking能正常运行、因此采用流量复制方案，一份流量打到skywalking-oap、一份到skywalking-bridge（自建bridge）。</p><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/011-root-cause-analyze/20220830214826.png" alt="image-20220830163208808"></p><ol><li>客户端skywalking-agent通过grpc上报segment数据到skywalking-gateway（Nginx）</li><li>Nginx拦截segment流量转发到skywalking-bridge，其他流量依旧到skywalking-oap</li><li>skywalking-bridge通过kafka转发segment数据到skywalking-oap，以保证skywalking正常运行</li><li>skywalking-bridge通过kafka转发segment数据到flink进行流式处理，flink会把解析segment数据为span并按分钟进行聚合处理生成指标数据</li><li>flink处理生成的指标数据通过kafka转发到skywalking-bridge</li><li>skywalking-bridge把指标数据保存到VictoraMetric时序数据库中</li><li>lingxi-diagnotor从VictoraMetric中获取数据进行根因分析</li></ol><h2 id="根因分析">根因分析</h2><h3 id="方案">方案</h3><p>我们如何知道一个服务有问题，通常情况下需要看监控大盘，观看上面的指标是否有抖动，耗时是否增加、成功率是否上升等。</p><p>什么叫抖动？某个服务耗时 500ms，某个 RPC 环节耗时 250ms，那么这个 RPC 环节一定是有问题的吗？不一定，必须要跟它正常情况进行一个对比才能知道它的这个耗时是否正常。所以需要一个正常水准，然后基于正常水准的对比才能确定某个环节是否抖动了。</p><p>所以我们方案的前提就是：</p><blockquote><p>需要有准确的异常开始时间，异常开始前一段时间范围要正常，基于前一段时间抖动程度来判定识别后一半时间范围的抖动是否为异常抖动</p></blockquote><p>然而不通应用不同端点耗时、成功率都有所不同，1ms-&gt;3ms上升200%，100ms-&gt;200ms上升100%，两组数据哪个有问题呢，可能后者问题更大。那么环比正常数据什么样的阈值才是有问题的，我们不可能针对每个应用每个端点去设置阈值，需要一个能够评判的标准，标准差应运而生。</p><ul><li><strong>方差</strong>是在概率论和统计方差衡量随机变量或一组数据时离散程度的度量。是每个样本值与全体样本值的平均数之差的平方值的平均数。</li><li>**标准差（Standard Deviation） **是离均差平方的算术平均数（即：方差）的算术平方根，用σ表示。标准差也被称为标准偏差，或者实验标准差，在概率统计中最常使用作为统计分布程度上的测量依据。</li></ul><p>方差和标准差都是对一组(一维)数据进行统计的，反映的是一维数组的离散程度。</p><p>标准差和均值的量纲（单位）是一致的，在描述一个波动范围是标准差比方差更方便。比如一个班男生的平均身高是170cm,标准差是10cm,那么方差就是10cm^2。可以进行的比较简便的描述是本班男生身高分布是170±10cm，方差就无法做到这点。</p><h3 id="实现逻辑">实现逻辑</h3><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/011-root-cause-analyze/20220830214816.png" alt="image-20220830163352915"></p><ol><li>计算入口端点前一个小时（可配置）正常数据的标准差A1，要分析时间范围的目标数据标准差A2</li><li>当A2是A1的3倍还多时（可配置），则认为端点抖动，可能有异常，下钻分析Local、Dubbo、Mysql、Redis指标<ul><li>耗时：当目标数据最大值&lt;正常数据平均值+A1，则过滤掉（去除向下波动数据）</li><li>失败率：当目标数据最小值&lt;正常数据平局值+A1，则过滤掉（去除向下波动数据）</li></ul></li><li>计算下钻指标前一个小时（可配置）正常数g准的标准差B1，和要分析时间范围的目标数据标准差B2</li><li>当B2是B1的3倍还多时（可配置），则认为指标波动，可能有异常</li><li>当指标为Dubbo是，记录客户端端点，继续递归分析</li></ol><h3 id="流程图">流程图</h3><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/011-root-cause-analyze/20220830214805.png" alt="image-20220830163244919"></p><h3 id=""></h3><h2 id="后续工作">后续工作</h2><ul><li><p>考虑接入CAT，丰富指标，增加准确性</p></li><li><p>考虑接入GC、CPU、Memory等指标，当分析出Local问题时能够精确给出因为什么原因导致</p></li><li><p>Metrics和调用链查询联动</p></li></ul><h2 id="参考">参考</h2><ol><li><a href="https://my.oschina.net/pingpangkuangmo/blog/4334872">https://my.oschina.net/pingpangkuangmo/blog/4334872</a></li><li><a href="https://zhuanlan.zhihu.com/p/407298025">https://zhuanlan.zhihu.com/p/407298025</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Skywalking</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Skywalking</tag>
      
      <tag>根因分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java日志体系</title>
    <link href="/posts/010-log-system.html"/>
    <url>/posts/010-log-system.html</url>
    
    <content type="html"><![CDATA[<p>前段时间Logj42 漏洞闹得沸沸扬扬，公司内部MSF框架及各应用也都在排查是否存在漏洞，并经过多个版本升级，趁这个机会深入了解下JAVA日志生态体系。</p><span id="more"></span><h1>log4j2漏洞</h1><h2 id="远程代码执行漏洞-CVE-2021-44228">远程代码执行漏洞 <strong>CVE-2021-44228</strong></h2><p>存在JNDI注入漏洞，当用户输入数据进行日志记录是，即可触发此漏洞，在启用消息查找替换时执行从LDAP服务器加载的任意代码。</p><p>影响版本：<code>2.0 - 2.15.0-rc1</code></p><p>修复版本：<strong><code>2.15.0 (Java 8)</code></strong></p><h2 id="远程代码执行漏洞-CVE-2021-45046">远程代码执行漏洞 CVE-2021-45046</h2><p>该漏洞为 CVE-2021-44228 修复的绕过，在某些特殊配置的情况下可能造成远程代码执行。当<code>Pattern Layouts</code>配置带有<code>Context Lookup</code>时(例如：<code>$$&#123;ctx:loginId&#125;</code>)容易受到这种情况的影响，成功利用该漏洞的攻击者能够造成远程代码执行</p><p>影响版本：<code>2.0 - 2.15.0</code></p><p>修复版本：<strong><code>2.16.0 (Java 8</code> <code>2.12.2 (Java 7)</code></strong></p><h2 id="拒绝服务攻击漏洞-CVE-2021-45105">拒绝服务攻击漏洞 CVE-2021-45105</h2><p>当日志配置使用带有Context Lookups的非默认 Pattern Layout（例如**$${ctx:loginId**}）时，攻击者可以通过构造包含递归查找的恶意输入数据，触发无限循环，导致 StackOverflowError，最终进程崩溃。</p><p>影响版本：<code>2.0 &lt;= 2.16.0</code></p><p>修复版本：<strong><code>2.17.0 (Java 8)</code> <code>2.12.3 (Java 7)</code>  <code>2.3.1 (Java 6)</code></strong></p><h2 id="远程代码执行漏洞-CVE-2021-44832">远程代码执行漏洞 CVE-2021-44832</h2><p>L攻击者通过将恶意的JNDI URI数据源写入JDBC Appender中，通过该JNDI URI可以远程加载代码并执行。在攻击者拥有修改配置文件权限时才可远程执行任意代码，利用难度较大。</p><p>影响版本：<code>2.0 - 2.17.0</code></p><p>修复版本：<strong><code>2.17.1 (Java 8)</code> <code>2.12.4 (Java 7)</code>  <code>2.3.2 (Java 6)</code></strong></p><h1>日志体系</h1><p>今天索性就彻底了解下JAVA的日志发展体系</p><h2 id="System-out和System-err"><strong>System.out和System.err</strong></h2><p>最早的日志记录方式，不灵活也不可配置，要么就是全部打印，要么就是全部不打印，没有日志级别，没有format，啥都没。</p><h2 id="Log4j"><strong>Log4j</strong></h2><p>1996年<code>E.U.SEMPER</code>（欧洲安全电子市场）决定编写自己的日志api，后来演变为log4j（作者 <code>Ceki Gülcü</code>）一经推出就得到了广泛应用，成为Java日志的标准，并成为了Apache的项目，2015年停止维护。</p><h2 id="JUL（Java-Util-Logging）"><strong>JUL（Java Util Logging）</strong></h2><p>Apache要求把log4j并入到JDK，遭到SUN公司拒绝，并在<code>JDK1.4</code>版本后，2002年2月推出了自己的日志库<code>Java Util Logging</code>。很多地方但显然比不过已经发布很多年的log4j。</p><h2 id="JCL（Jakarta-Commons-Logging）"><strong>JCL（Jakarta Commons Logging）</strong></h2><p>2002年8月<code>Apache</code>又推出了日志接口<code>Jakarta Commons Logging</code>，也就是日志抽象层，提供了一个默认实现<code>Simple Log</code>。</p><p>只要依赖了<code>JCL</code>接口，就可以很方便的在<code>Log4j</code>和<code>JUL</code>以及<code>Simple Log</code>之间做切换。</p><h1>log4j2漏洞</h1><h2 id="远程代码执行漏洞-CVE-2021-44228-2">远程代码执行漏洞 <strong>CVE-2021-44228</strong></h2><p>存在JNDI注入漏洞，当用户输入数据进行日志记录是，即可触发此漏洞，在启用消息查找替换时执行从LDAP服务器加载的任意代码。</p><p>影响版本：<code>2.0 - 2.15.0-rc1</code></p><p>修复版本：<strong><code>2.15.0 (Java 8)</code></strong></p><h2 id="远程代码执行漏洞-CVE-2021-45046-2">远程代码执行漏洞 CVE-2021-45046</h2><p>该漏洞为 CVE-2021-44228 修复的绕过，在某些特殊配置的情况下可能造成远程代码执行。当<code>Pattern Layouts</code>配置带有<code>Context Lookup</code>时(例如：<code>$$&#123;ctx:loginId&#125;</code>)容易受到这种情况的影响，成功利用该漏洞的攻击者能够造成远程代码执行</p><p>影响版本：<code>2.0 - 2.15.0</code></p><p>修复版本：<strong><code>2.16.0 (Java 8</code> <code>2.12.2 (Java 7)</code></strong></p><h2 id="拒绝服务攻击漏洞-CVE-2021-45105-2">拒绝服务攻击漏洞 CVE-2021-45105</h2><p>当日志配置使用带有Context Lookups的非默认 Pattern Layout（例如**$${ctx:loginId**}）时，攻击者可以通过构造包含递归查找的恶意输入数据，触发无限循环，导致 StackOverflowError，最终进程崩溃。</p><p>影响版本：<code>2.0 &lt;= 2.16.0</code></p><p>修复版本：<strong><code>2.17.0 (Java 8)</code> <code>2.12.3 (Java 7)</code>  <code>2.3.1 (Java 6)</code></strong></p><h2 id="远程代码执行漏洞-CVE-2021-44832-2">远程代码执行漏洞 CVE-2021-44832</h2><p>L攻击者通过将恶意的JNDI URI数据源写入JDBC Appender中，通过该JNDI URI可以远程加载代码并执行。在攻击者拥有修改配置文件权限时才可远程执行任意代码，利用难度较大。</p><p>影响版本：<code>2.0 - 2.17.0</code></p><p>修复版本：<strong><code>2.17.1 (Java 8)</code> <code>2.12.4 (Java 7)</code>  <code>2.3.2 (Java 6)</code></strong></p><h1>日志体系</h1><p>今天索性就彻底了解下JAVA的日志发展体系</p><h2 id="System-out和System-err-2"><strong>System.out和System.err</strong></h2><p>最早的日志记录方式，不灵活也不可配置，要么就是全部打印，要么就是全部不打印，没有日志级别，没有format，啥都没。</p><h2 id="Log4j-2"><strong>Log4j</strong></h2><p>1996年<code>E.U.SEMPER</code>（欧洲安全电子市场）决定编写自己的日志api，后来演变为log4j（作者 <code>Ceki Gülcü</code>）一经推出就得到了广泛应用，成为Java日志的标准，并成为了Apache的项目，2015年停止维护。</p><h2 id="JUL（Java-Util-Logging）-2"><strong>JUL（Java Util Logging）</strong></h2><p>Apache要求把log4j并入到JDK，遭到SUN公司拒绝，并在<code>JDK1.4</code>版本后，2002年2月推出了自己的日志库<code>Java Util Logging</code>。很多地方但显然比不过已经发布很多年的log4j。</p><h2 id="JCL（Jakarta-Commons-Logging）-2"><strong>JCL（Jakarta Commons Logging）</strong></h2><p>2002年8月<code>Apache</code>又推出了日志接口<code>Jakarta Commons Logging</code>，也就是日志抽象层，提供了一个默认实现<code>Simple Log</code>。</p><p>只要依赖了<code>JCL</code>接口，就可以很方便的在<code>Log4j</code>和<code>JUL</code>以及<code>Simple Log</code>之间做切换。</p><h2 id="Slf4j（Simple-Logging-Facade-for-Java）"><strong>Slf4j（Simple Logging Facade for Java）</strong></h2><blockquote><p>The Simple Logging Facade for Java (SLF4J) serves as a simple facade or abstraction for various logging frameworks (e.g. java.util.logging, logback, log4j) allowing the end user to plug in the desired logging framework at <em>deployment</em> time.</p></blockquote><p>Java的简单日志记录外观 (SLF4J) 用作各种日志记录框架 (例如java.util.Logging，logback，log4j) 的简单外观或抽象，允许最终用户在部署时插入所需的日志记录框架</p><p><code>Ceki Gülcü</code> 离开Apache后，于是于2005年推出了一套新日志接口：<code>Slf4j（Simple Logging Facade for Java）</code>，后面也确实证明了<code>Slf4j</code>是要比<code>JCL</code>在很多地方更优秀。</p><p>但是由于<code>Slf4j</code>出来的较晚，而且还只是一个日志接口，之前已经出现的日志产品，如<code>JUL</code>和<code>Log4j</code>都是没有实现这个接口的，所以大佬自己撸了一套适配的桥接包，实现了java日志界的大一统。</p><p>简单来说</p><h2 id="Logback">Logback</h2><p>由于其他日志框架使用<code>Slf4j</code>，需要使用适配桥接包，也就是之前的日志产品都不是正统的<code>Slf4j</code>的实现，2006年，<strong>Ceki Gülcü又撸了一套原生实现Slf4j接口的Logback</strong>应运而生，</p><p><a href="https://logback.qos.ch/reasonsToSwitch.html">https://logback.qos.ch/reasonsToSwitch.html</a></p><blockquote><p>Logback brings a large number of improvements over log4j 1.x, big and small. They are too many to enumerate exhaustively. Nevertheless, here is a non-exhaustive list of reasons for switching to logback from log4j 1.x. Keep in mind that logback is conceptually very similar to log4j 1.x as both projects were founded by the same developer. If you are already familiar with log4j 1.x, you will quickly feel at home using logback.</p></blockquote><p>大概意思就是比log4j1.x有很多改进，可以很方便从log4j1.x切换到logback</p><h2 id="Log4j2">Log4j2</h2><p>在2012年，<code>Apache</code>直接推出了新项目<code>Log4j2</code>，不是<code>Log4j1.x</code>升级，因为<code>Log4j2</code>完全不兼容<code>Log4j1.x</code>。</p><p>并且Log4j2几乎涵盖Logback所有的特性，并且相比Logback拥有：</p><ul><li>更简化的配置</li><li>更强大的参数格式化</li><li>最夸张的异步性能</li></ul><p>并且很微妙的，<code>Log4j2</code>几乎涵盖<code>Logback</code>所有的特性（这不是对着干是啥~而且还有抄袭的嫌疑。。。哈哈哈），更甚者的<code>Log4j2</code>也搞了分离的设计，分化成<code>log4j-api</code>和<code>log4j-core</code>，这个<code>log4j-api</code>也是日志接口，<code>log4j-core</code>才是日志产品。。。</p><blockquote><p>Log4j 2 contains next-generation Asynchronous Loggers based on the LMAX Disruptor library. In multi-threaded scenarios Asynchronous Loggers have 18 times higher throughput and orders of magnitude lower latency than Log4j 1.x and Logback.</p></blockquote><p>log4j2异步日志使用了<code>LMAX Disruptor</code> , 一个无锁的线程间通信框架, 并发性能大大提升。</p><p>从图上可以看出，log4j2的异步（全异步，非混合模式）下的性能，远超log4j1和logback。压力越大的情况下，吞吐上的差距就越大。在64线程测试下，log4j2的吞吐达到了180w+/s，而logback/log4j1只有不到20w，相差近十倍</p><h1>最佳实践</h1><ol><li>不要使用root权限去启动进程，漏洞攻击者可以使用root权限做太多事情。</li><li>我们应该依赖日志的抽象，而不是日志的实现，使用日志接口的<code>API</code>而不是直接使用日志实现的<code>API</code>。</li><li>日志实现的依赖只添加一个，依赖多个日志产品，会让应用处理日志显得更复杂，无法统一控制。</li><li>日志的<code>scope</code>  设置为<code>runtime</code> ，保证日志的产品的依赖只有在运行时需要，编译时不需要，开发就不会使用到日志实现的<code>API</code>了。</li><li>Log4j2仍是然是目前性能最好的日志框架。</li></ol><h1>参考文献</h1><ol><li><a href="https://logging.apache.org/log4j/2.x/manual/async.html#Performance">https://logging.apache.org/log4j/2.x/manual/async.html#Performance</a></li><li><a href="https://logging.apache.org/log4j/2.x/security.html">https://logging.apache.org/log4j/2.x/security.html</a></li><li><a href="https://logback.qos.ch/index.html">https://logback.qos.ch/index.html</a></li><li><a href="https://www.slf4j.org/">https://www.slf4j.org/</a></li><li><a href="https://lmax-exchange.github.io/disruptor/disruptor.html">https://lmax-exchange.github.io/disruptor/disruptor.html</a></li><li><a href="https://new.qq.com/omn/20211228/20211228A0559300.html">https://new.qq.com/omn/20211228/20211228A0559300.html</a></li><li><a href="https://tech.meituan.com/2016/11/18/disruptor.html">https://tech.meituan.com/2016/11/18/disruptor.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Log</tag>
      
      <tag>Slf4j</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bloom Filter - 布隆过滤器</title>
    <link href="/posts/009-bloom-filter.html"/>
    <url>/posts/009-bloom-filter.html</url>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p><strong>布隆过滤器</strong>（英语：Bloom Filter）是1970年由布隆（Burton Howard Bloom）提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><span id="more"></span><h2 id="原理">原理</h2><h3 id="通常判断某个元素是否存在用什么？">通常判断某个元素是否存在用什么？</h3><p>HashMap 确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率很高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。</p><blockquote><p>一个 email 地址需要占用十六个字节。</p><p>HashMap：一亿个地址大约要 1.6GB， 即十六亿字节的内存</p><p>Bloom Filter：一亿个地址，千分之一误报率，大约需要171MB</p></blockquote><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/gitee/20210831133846.png" alt="image-20210831133846915"></p><h3 id="布隆过滤器">布隆过滤器</h3><p>布隆过滤器主要做用就是查询一个数据，在不在这个二进制的集合中，过程如下：</p><ul><li>经过K个哈希函数计算该数据，对应计算出的K个hash值</li><li>经过hash值找到对应的二进制的数组下标</li><li>判断：若是存在一处位置的二进制数据是0，那么该数据不存在。若是都是1，该数据存在集合中。</li></ul><p>举个栗子：</p><p>假设有3个hash函数，key1 通过3个hash函数生成hash值对数组长度取模得到下标分别为1、5、7，key1 通过3个hash函数生成hash值对数组长度取模得到下标分别为2、4、7。</p><p>当我们查询key3时，假设下标为1，4，5发现三个位置都为1，那么key3一定存在么？不一定，key3可能存在。因为随着增加的值越来越多，被置为1的位置越来越多，具有一定概率的误判性。（不同值计算出来的hash值有可能相同，hash值不同，原值一定不同）</p><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/gitee/20210831132032.png" alt="image-20210831132032831"></p><h3 id="公式">公式</h3><p>m代表bit位的数量（字节数组长度）， n代表插入的元素个数，k代表hash函数个数，p代表误报率</p><h4 id="计算hash函数数量">计算hash函数数量</h4><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/gitee/20210831164308.png" alt="image-20210831164307923"></p><p>当m/n=10的时候我们需要的k元素数量为7，也就是7个哈希函数才能实现一个比较低的误报率。</p><h4 id="计算需要字节数">计算需要字节数</h4><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/gitee/20210831160043.png" alt="image-20210831160043594"></p><p>下图是布隆过滤器误报率 p 与位数组大小 m 和集合中插入元素个数 n 的关系图，假定 Hash 函数个数选取最优数目</p><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/gitee/20210831141613.png" alt="File:Bloom filter fp probability.svg"></p><h4 id="在线布隆计算器：https-hur-st-bloomfilter">在线布隆计算器：<a href="https://hur.st/bloomfilter/">https://hur.st/bloomfilter/</a></h4><p>假定插入元素个数n=1亿，误报率为千分之一，则预计字节数组大小为171MB，hash函数个数为10</p><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/gitee/20210831142230.png" alt="image-20210831142230627"></p><h2 id="优点">优点</h2><ol><li>因为存储的是二进制数据，因此占用的空间很小</li><li>它的插入和查询速度是很是快的，时间复杂度是O(K)</li><li>保密性很好，由于自己不存储任何原始数据，只有二进制数据</li></ol><h2 id="缺点">缺点</h2><ol><li>存在一定误报率</li><li>需要预估插入数据量，超过则误报率大大提升</li><li>不能删除（<a href="https://en.wikipedia.org/wiki/Counting_Bloom_filter">Counting Bloom filter</a> 计数过滤器提供了一种在Bloom过滤器上实现删除操作而无需重新创建过滤器的方法）</li></ol><h2 id="应用">应用</h2><ul><li>公司Dmp数据营销项目使用布隆过滤器来判断是否推送过广告。</li><li>公司Pwc爬虫使用布隆过滤器来判断是否爬取过url。</li><li>Google Bigtable、Apache HBase和Apache Cassandra和PostgreSQL 使用布隆过滤器来减少对不存在的行或列的磁盘查找。避免昂贵的磁盘查找可显着提高数据库查询操作的性能。</li><li>Google Chrome浏览器使用了布隆过滤器加速安全浏览服务。</li><li>Microsoft Bing搜索引擎对其搜索索引BitFunnel使用多级分层布隆过滤器。</li><li>Redis 缓存穿透</li></ul><blockquote><p>Bloom filter used to speed up answers in a key-value storage system. Values are stored on a disk which has slow access times. Bloom filter decisions are much faster. However some unnecessary disk accesses are made when the filter reports a positive (in order to weed out the false positives). Overall answer speed is better with the Bloom filter than without the Bloom filter. Use of a Bloom filter for this purpose, however, does increase memory usage</p><p>在很多Key-Value系统中使用了布隆过滤器来加快查询过程，Value 保存在访问时间较慢的磁盘中，布隆过滤器可以快速判断某个Key对应的Value是否存在，然而某些误报会导致磁盘访问磁盘。总体来说，使用Bloom过滤比不使用Bloom过滤的应答速度更快，但是是引入布隆过滤器会带来一定的内存消耗</p></blockquote><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/gitee/20210831185353.png" alt="img"></p><h2 id="Guava实现布隆过滤器">Guava实现布隆过滤器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 预计要插入多少数据</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000000</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 期望的误判率</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-variable">fpp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.001</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 布隆过滤器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), size, fpp);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 插入10万样本数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        bloomFilter.put(i);<br>    &#125;<br><br>    <span class="hljs-comment">// 用另外十万测试数据，测试误判率</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size; i &lt; size + <span class="hljs-number">100000</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (bloomFilter.mightContain(i)) &#123;<br>            count++;<br>            System.out.println(i + <span class="hljs-string">&quot;误判了&quot;</span>);<br>        &#125;<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;总共的误判数:&quot;</span> + count);<br>&#125;<br><br><span class="hljs-number">1097387</span>误判了<br><span class="hljs-number">1097421</span>误判了<br><span class="hljs-number">1098501</span>误判了<br>.<br>.<br>.<br>总共的误判数:<span class="hljs-number">114</span><br></code></pre></td></tr></table></figure><h3 id="创建过滤器">创建过滤器</h3><ul><li><code>funnel</code>：数据类型(通常是调用Funnels工具类中的)</li><li><code>expectedInsertions</code>：指望插入的值的个数</li><li><code>fpp</code>：误判率(默认值为0.03)</li><li><code>strategy</code>：哈希算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; BloomFilter&lt;T&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(</span><br><span class="hljs-params">    Funnel&lt;? <span class="hljs-built_in">super</span> T&gt; funnel, <span class="hljs-type">long</span> expectedInsertions, <span class="hljs-type">double</span> fpp, Strategy strategy)</span> &#123;<br>  checkNotNull(funnel);<br>  checkArgument(<br>      expectedInsertions &gt;= <span class="hljs-number">0</span>, <span class="hljs-string">&quot;Expected insertions (%s) must be &gt;= 0&quot;</span>, expectedInsertions);<br>  checkArgument(fpp &gt; <span class="hljs-number">0.0</span>, <span class="hljs-string">&quot;False positive probability (%s) must be &gt; 0.0&quot;</span>, fpp);<br>  checkArgument(fpp &lt; <span class="hljs-number">1.0</span>, <span class="hljs-string">&quot;False positive probability (%s) must be &lt; 1.0&quot;</span>, fpp);<br>  checkNotNull(strategy);<br><br>  <span class="hljs-keyword">if</span> (expectedInsertions == <span class="hljs-number">0</span>) &#123;<br>    expectedInsertions = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * TODO(user): Put a warning in the javadoc about tiny fpp values, since the resulting size</span><br><span class="hljs-comment">   * is proportional to -log(p), but there is not much of a point after all, e.g.</span><br><span class="hljs-comment">   * optimalM(1000, 0.0000000000000001) = 76680 which is less than 10kb. Who cares!</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-comment">// 计算需要的字节数</span><br>  <span class="hljs-type">long</span> <span class="hljs-variable">numBits</span> <span class="hljs-operator">=</span> optimalNumOfBits(expectedInsertions, fpp);<br>  <span class="hljs-comment">// 计算需要的hash函数数量</span><br>  <span class="hljs-type">int</span> <span class="hljs-variable">numHashFunctions</span> <span class="hljs-operator">=</span> optimalNumOfHashFunctions(expectedInsertions, numBits);<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BloomFilter</span>&lt;T&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LockFreeBitArray</span>(numBits), numHashFunctions, funnel, strategy);<br>  &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Could not create BloomFilter of &quot;</span> + numBits + <span class="hljs-string">&quot; bits&quot;</span>, e);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入">插入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CanIgnoreReturnValue</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">put</span><span class="hljs-params">(T object)</span> &#123;<br>  <span class="hljs-keyword">return</span> strategy.put(object, funnel, numHashFunctions, bits);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">put</span><span class="hljs-params">(</span><br><span class="hljs-params">  T object, Funnel&lt;? <span class="hljs-built_in">super</span> T&gt; funnel, <span class="hljs-type">int</span> numHashFunctions, LockFreeBitArray bits)</span> &#123;<br>  <span class="hljs-type">long</span> <span class="hljs-variable">bitSize</span> <span class="hljs-operator">=</span> bits.bitSize();<br>  <span class="hljs-type">byte</span>[] bytes = Hashing.murmur3_128().hashObject(object, funnel).getBytesInternal();<br>  <span class="hljs-type">long</span> <span class="hljs-variable">hash1</span> <span class="hljs-operator">=</span> lowerEight(bytes);<br>  <span class="hljs-type">long</span> <span class="hljs-variable">hash2</span> <span class="hljs-operator">=</span> upperEight(bytes);<br><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">bitsChanged</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-type">long</span> <span class="hljs-variable">combinedHash</span> <span class="hljs-operator">=</span> hash1;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numHashFunctions; i++) &#123;<br>    <span class="hljs-comment">// Make the combined hash positive and indexable</span><br>    bitsChanged |= bits.set((combinedHash &amp; Long.MAX_VALUE) % bitSize);<br>    combinedHash += hash2;<br>  &#125;<br>  <span class="hljs-keyword">return</span> bitsChanged;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="判断是否可能包含元素">判断是否可能包含元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns &#123;<span class="hljs-doctag">@code</span> true&#125; if the element &lt;i&gt;might&lt;/i&gt; have been put in this Bloom filter, &#123;<span class="hljs-doctag">@code</span></span><br><span class="hljs-comment"> * false&#125; if this is &lt;i&gt;definitely&lt;/i&gt; not the case.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">mightContain</span><span class="hljs-params">(T object)</span> &#123;<br>  <span class="hljs-keyword">return</span> strategy.mightContain(object, funnel, numHashFunctions, bits);<br>&#125;<br><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-type">boolean</span> <span class="hljs-title function_">mightContain</span><span class="hljs-params">(</span><br><span class="hljs-params">  T object, Funnel&lt;? <span class="hljs-built_in">super</span> T&gt; funnel, <span class="hljs-type">int</span> numHashFunctions, LockFreeBitArray bits)</span> &#123;<br>  <span class="hljs-type">long</span> <span class="hljs-variable">bitSize</span> <span class="hljs-operator">=</span> bits.bitSize();<br>  <span class="hljs-type">byte</span>[] bytes = Hashing.murmur3_128().hashObject(object, funnel).getBytesInternal();<br>  <span class="hljs-type">long</span> <span class="hljs-variable">hash1</span> <span class="hljs-operator">=</span> lowerEight(bytes);<br>  <span class="hljs-type">long</span> <span class="hljs-variable">hash2</span> <span class="hljs-operator">=</span> upperEight(bytes);<br><br>  <span class="hljs-type">long</span> <span class="hljs-variable">combinedHash</span> <span class="hljs-operator">=</span> hash1;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numHashFunctions; i++) &#123;<br>    <span class="hljs-comment">// Make the combined hash positive and indexable</span><br>    <span class="hljs-keyword">if</span> (!bits.get((combinedHash &amp; Long.MAX_VALUE) % bitSize)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    combinedHash += hash2;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考文献">参考文献</h2><ol><li><a href="https://en.wikipedia.org/wiki/Bloom_filter">https://en.wikipedia.org/wiki/Bloom_filter</a></li><li><a href="https://www.cnblogs.com/liyulong1982/p/6013002.html">https://www.cnblogs.com/liyulong1982/p/6013002.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Bloom Filter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue中 v-model双向绑定</title>
    <link href="/posts/008-v-model-binding.html"/>
    <url>/posts/008-v-model-binding.html</url>
    
    <content type="html"><![CDATA[<h2 id="v-model双向绑定">v-model双向绑定</h2><p>Vue 中使用 v-model 可以实现双向绑定</p><span id="more"></span><p>先看一个小栗子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div id=&quot;app&quot;&gt;<br>    &lt;p&gt;&#123;&#123; city &#125;&#125;&lt;/p&gt;<br>    &lt;input type=&quot;text&quot; v-model=&quot;city&quot; /&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  name: &quot;App&quot;,<br>  data() &#123;<br>    return &#123;<br>      city: &#x27;北京&#x27;<br>    &#125;<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>city 的值通过 v-model 绑定到 input 上，因此它会根据 input 输入框的值进行动态变化。根据官方文档的解释，v-model 其实是一个语法糖，它会自动的在元素或者组件上面解析为 <code>:value = &quot; &quot;</code> 和 <code>@input = &quot; &quot;</code> 。所以我们可以将上述代码进行拆解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div id=&quot;app&quot;&gt;<br>    &lt;p&gt;&#123;&#123; city &#125;&#125;&lt;/p&gt;<br>    &lt;input type=&quot;text&quot; :value=&quot;city&quot; @input=&quot;city = $event.target.value&quot; /&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h2 id="自定义组件v-model双向绑定">自定义组件v-model双向绑定</h2><p>不使用 v-model，我们也可以得到相同的效果。上述代码中，当在 input 输入框输入内容时，会自动的触发 input 事件，更新绑定的 city 值为当前 input 框输入的值。所以，了解这些后，我们是否可以在自己写的组件上面实现 v-model 的效果呢？</p><p>官方文档：<a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model">自定义组件的 v-model</a>。这里我们将官网的栗子改造一下拿过来：</p><p>父组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div id=&quot;app&quot;&gt;<br>    &lt;p&gt;&#123;&#123; name &#125;&#125;&lt;/p&gt;<br>    &lt;!--自定义组件上使用 v-model，name 的值会传入到子组件 model-prop-text 中--&gt;<br>    &lt;CustomVModel v-model=&quot;name&quot; /&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>import CustomVModel from &#x27;./components/CustomVModel&#x27;<br>export default &#123;<br>  name: &quot;App&quot;,<br>  components: &#123; CustomVModel &#125;,<br>  data() &#123;<br>    return &#123;<br>      name: &#x27;张三&#x27;<br>    &#125;<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>子组件 CustomVModel.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;input<br>    type=&quot;text&quot;<br>    :value=&quot;text&quot;<br>    @input=&quot;$emit(&#x27;change&#x27;, $event.target.value)&quot;<br>  /&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default &#123;<br>  model: &#123;<br>    prop: &#x27;text&#x27;, // 可任意定义的变量，用来接收父组件 v-model 中传递过来的值<br>    event: &#x27;change&#x27;<br>  &#125;,<br>  props: &#123;<br>    text: String, // 对自己定义的变量的类型和默认值进行声明，必须和自己定义的变量名相同<br>    default() &#123;<br>      return &#x27;&#x27;<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><blockquote><p>根据官方文档给出的说法：父组件中的 name 的值将会传入子组件中名为 text(该名称可自己定义:默认为value) 的 prop 中，同时子组件的 input 如果触发 @input 事件并附带一个新的值的时候，父组件中 name 的值也会被重新更新。当然，我们还是需要在子组件的 props 选项里声明 text 这个 prop。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>双向绑定</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WeakHashMap -弱引用 HashMap</title>
    <link href="/posts/007-weakhashmap.html"/>
    <url>/posts/007-weakhashmap.html</url>
    
    <content type="html"><![CDATA[<p>WeakHashMap，此种 Map 的特点是，当除了自身有对 key 的引用外，此 key 没有其他引用那么此 map 会自动丢弃此值，所以比较适合做缓存。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeakHashMap</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;<br></code></pre></td></tr></table></figure><p>WeakHashMap 实现了 Map 接口，基于 hash-table 实现，在这种 Map 中，key 的类型是 WeakReference。如果对应的 key 被回收，则这个 key 指向的对象会被从 Map 容器中移除。</p><h2 id="典型使用场景：-tomcat-两级缓存">典型使用场景： tomcat 两级缓存</h2><p>tomcat 的源码里，实现缓存时会用到 WeakHashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.apache.tomcat.util.collections;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.WeakHashMap;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentCache</span>&lt;K,V&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;K,V&gt; eden;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;K,V&gt; longterm;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentCache</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-built_in">this</span>.size = size;<br>        <span class="hljs-built_in">this</span>.eden = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(size);<br>        <span class="hljs-built_in">this</span>.longterm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;&gt;(size);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K k)</span> &#123;<br>        <span class="hljs-type">V</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.eden.get(k);<br>        <span class="hljs-keyword">if</span> (v == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (longterm) &#123;<br>                v = <span class="hljs-built_in">this</span>.longterm.get(k);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (v != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-built_in">this</span>.eden.put(k, v);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> v;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(K k, V v)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.eden.size() &gt;= size) &#123;<br>            <span class="hljs-keyword">synchronized</span> (longterm) &#123;<br>                <span class="hljs-built_in">this</span>.longterm.putAll(<span class="hljs-built_in">this</span>.eden);<br>            &#125;<br>            <span class="hljs-built_in">this</span>.eden.clear();<br>        &#125;<br>        <span class="hljs-built_in">this</span>.eden.put(k, v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>源码中有 eden 和 longterm 的两个 map，对 jvm 堆区有所了解的话，可以猜测出 tomcat 在这里是使用 ConcurrentHashMap 和 WeakHashMap 做了分代的缓存。</p><ul><li>在 put 方法里，在插入一个 k-v 时，先检查 eden 缓存的容量是不是超了。没有超就直接放入 eden 缓存，如果超了则锁定 longterm 将 eden 中所有的 k-v 都放入 longterm。再将 eden 清空并插入 k-v。</li><li>在 get 方法中，也是优先从 eden 中找对应的 v，如果没有则进入 longterm 缓存中查找，找到后就加入 eden 缓存并返回。</li></ul><p>经过这样的设计，相对常用的对象都能在 eden 缓存中找到，不常用（有可能被销毁的对象）的则进入 longterm 缓存。而 longterm 的 key 的实际对象没有其他引用指向它时，gc 就会自动回收 heap 中该弱引用指向的实际对象，弱引用进入引用队列。longterm 调用 expungeStaleEntries()方法，遍历引用队列中的弱引用，并清除对应的 Entry，不会造成内存空间的浪费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Expunges stale entries from the table.</span><br><span class="hljs-comment"> * 遍历引用队列中的弱引用，并清除对应的Entry</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expungeStaleEntries</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (Object x; (x = queue.poll()) != <span class="hljs-literal">null</span>; ) &#123;<br>        <span class="hljs-keyword">synchronized</span> (queue) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(e.hash, table.length);<br><br>            Entry&lt;K,V&gt; prev = table[i];<br>            Entry&lt;K,V&gt; p = prev;<br>            <span class="hljs-keyword">while</span> (p != <span class="hljs-literal">null</span>) &#123;<br>                Entry&lt;K,V&gt; next = p.next;<br>                <span class="hljs-keyword">if</span> (p == e) &#123;<br>                    <span class="hljs-keyword">if</span> (prev == e)<br>                        table[i] = next;<br>                    <span class="hljs-keyword">else</span><br>                        prev.next = next;<br>                    <span class="hljs-comment">// Must not null out e.next;</span><br>                    <span class="hljs-comment">// stale entries may be in use by a HashIterator</span><br>                    e.value = <span class="hljs-literal">null</span>; <span class="hljs-comment">// Help GC</span><br>                    size--;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                prev = p;<br>                p = next;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="强引用（StrongReference）">强引用（StrongReference）</h3><p>被强引用指向的对象，绝对不会被垃圾收集器回收。Integer prime = 1;，这个语句中 prime 对象就有一个强引用。</p><h3 id="软引用（SoftReference）">软引用（SoftReference）</h3><p>被 SoftReference 指向的对象可能会被垃圾收集器回收，但是只有在 JVM 内存不够的情况下才会回收；如下代码可以创建一个软引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">prime</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>SoftReference&lt;Integer&gt; soft = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;Integer&gt;(prime);<br>prime = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><h3 id="弱引用（WeakReference）">弱引用（WeakReference）</h3><p>当一个对象仅仅被 WeakReference 引用时，在下个垃圾收集周期时候该对象就会被回收。我们通过下面代码创建一个 WeakReference：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">prime</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>WeakReference&lt;Integer&gt; soft = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;Integer&gt;(prime);<br>prime = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>当把 prime 赋值为 null 的时候，原 prime 对象会在下一个垃圾收集周期中被回收，因为已经没有强引用指向它。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>try-with-resource</title>
    <link href="/posts/006-try-with-resources.html"/>
    <url>/posts/006-try-with-resources.html</url>
    
    <content type="html"><![CDATA[<h1>背景</h1><p>Java 中包含许多需要调用 close 才能关闭的资源，如<code>InputStream</code>、<code>OutputStream</code>、<code>java.sql.Connection</code></p><p>忘记关闭会造成很严重的性能后果，关闭的方法有<code>finalizer</code>、<code>try-catch-finally</code>、<code>try-with-resources</code>等</p><span id="more"></span><h1>finalizer</h1><ul><li>finalizer（终结方法）通常是不可预测的，很危险的（详见 Effective java 第 8 条）</li><li>终结方法不能保证会被及时的执行，从一个对象变得不可到达开始，到终结方法被执行，花费时间是任意长的。</li><li>JAVA 语言规范也不保证终结方法会被执行</li><li>终结方法有很严重性能损失</li></ul><h1>try-catch-finally</h1><p><code>try-catch-finally</code> 是确保资源被关闭的最佳方法，就算发生异常 finally 也一样会执行</p><p>但是，当关闭多个资源时会出现问题，代码不够优雅，<code>嵌套越来越深</code>，并且假如代码抛出异常，finally 也抛出异常，会导致第二个异常会覆盖第一个异常，<code>导致异常屏蔽问题</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        InputStream in= <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;bbb&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>                <span class="hljs-type">int</span> n;<br>                <span class="hljs-keyword">while</span> ((n = in.read(buf))&gt;=<span class="hljs-number">0</span>)&#123;<br>                    out.write(buf,<span class="hljs-number">0</span>,n);<br>                &#125;<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                out.close();<br>            &#125;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            in.close();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="try-catch-finally-的执行顺序">try-catch-finally 的执行顺序</h2><ul><li>代码没有异常 执行顺序：try 执行完整-&gt;catch 不执行-&gt;finally 执行</li><li>代码有异常且 catch 进行捕获 执行顺序：try 执行部分-&gt;跳转 catch 捕获处理-&gt;finally 执行</li><li>代码有异常且 catch 不捕获：这种情况没有 catch 执行顺序：try 执行部分-&gt;finally 执行</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">当<span class="hljs-keyword">finally</span>有<span class="hljs-keyword">return</span>时，会直接返回,不会再去返回<span class="hljs-keyword">try</span>或者<span class="hljs-keyword">catch</span>中的返回值，而<span class="hljs-keyword">finally</span>没有<span class="hljs-keyword">return</span>时，<span class="hljs-keyword">try</span>和<span class="hljs-keyword">catch</span> 的<span class="hljs-keyword">return</span>语句并不会马上执行，而是执行完<span class="hljs-keyword">finally</span>代码块之后再返回<span class="hljs-keyword">try</span>和<span class="hljs-keyword">catch</span>里面的值。<br></code></pre></td></tr></table></figure><h1>try-with-resources</h1><p><code>try-with-resources</code> 是<code>jdk1.7</code>引入的语法糖，使得关闭资源操作无需层层嵌套在 finally。</p><p>要使用这个功能，必须要实现<code>AutoCloseable</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;aaa&quot;</span>);<br>             <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;bbb&quot;</span>)) &#123;<br>            <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-type">int</span> n;<br>            <span class="hljs-keyword">while</span> ((n = in.read(buf)) &gt;= <span class="hljs-number">0</span>) &#123;<br>                out.write(buf, <span class="hljs-number">0</span>, n);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="原理">原理</h2><p>编译器编译时会<code>自动帮我们补全close()</code>，而且可以<code>避免异常屏蔽</code></p><p>从<code>Java 1.7</code>开始，为 Throwable 类新增了 <code>addSuppressed</code> 方法，支持将一个异常附加到另一个异常身上，从而避免异常屏蔽。</p><p>反编译代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;aaa&quot;</span>);<br>        <span class="hljs-type">Throwable</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;bbb&quot;</span>);<br>            <span class="hljs-type">Throwable</span> <span class="hljs-variable">var4</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><br>                <span class="hljs-type">int</span> n;<br>                <span class="hljs-keyword">while</span>((n = in.read(buf)) &gt;= <span class="hljs-number">0</span>) &#123;<br>                    out.write(buf, <span class="hljs-number">0</span>, n);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable var28) &#123;<br>                var4 = var28;<br>                <span class="hljs-keyword">throw</span> var28;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (out != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (var4 != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            out.close();<br>                        &#125; <span class="hljs-keyword">catch</span> (Throwable var27) &#123;<br>                            var4.addSuppressed(var27);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        out.close();<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var30) &#123;<br>            var2 = var30;<br>            <span class="hljs-keyword">throw</span> var30;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (in != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (var2 != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        in.close();<br>                    &#125; <span class="hljs-keyword">catch</span> (Throwable var26) &#123;<br>                        var2.addSuppressed(var26);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    in.close();<br>                &#125;<br>            &#125;<br><br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h1>结论</h1><p>处理必须关闭的资源时，始终要<code>优先考虑使用try-with-resources</code>，而不是 try-finally。这样得到的代码将更简洁，清晰，产生的异常也更有价值，这些也是 try-finally 无法做到的。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo 自定义标签路由</title>
    <link href="/posts/005-dubbo-tag-invoker-chain.html"/>
    <url>/posts/005-dubbo-tag-invoker-chain.html</url>
    
    <content type="html"><![CDATA[<h1><strong>简介</strong></h1><p>标签路由通过将某一个或多个服务的提供者划分到同一个分组，约束流量只在指定分组中流转，从而实现流量隔离的目的，可以作为蓝绿发布、灰度发布等场景的能力基础。</p><span id="more"></span><p>官网地址：<a href="https://dubbo.apache.org/zh/docs/v2.7/user/examples/routing-rule/#%E6%A0%87%E7%AD%BE%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99">路由规则</a></p><p>由于 dubbo 官方路由规则无法满足业务需要，因此自定义标签路由实现</p><h1>自定义路由</h1><h2 id="实现-Router-接口，重写-route-方法">实现 Router 接口，重写 route 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">xxxTagRouter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRouter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TAG_ROUTER_DEFAULT_PRIORITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">150</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(MsfTagRouter.class);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">xxxTagRouter</span><span class="hljs-params">(URL url)</span> &#123;<br>        <span class="hljs-built_in">this</span>.url = url;<br>        <span class="hljs-built_in">this</span>.priority = TAG_ROUTER_DEFAULT_PRIORITY;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> URL <span class="hljs-title function_">getUrl</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> url;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; <span class="hljs-title function_">route</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class="hljs-keyword">throws</span> RpcException &#123;<br>        <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;<br>            <span class="hljs-keyword">return</span> invokers;<br>        &#125;<br>        <span class="hljs-keyword">return</span> filterTag(invokers, url, invocation);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; <span class="hljs-title function_">filterTag</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> &#123;<br>        List&lt;Invoker&lt;T&gt;&gt; result;<br><br>        <span class="hljs-comment">// Tag request</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(tag)) &#123;<br>            <span class="hljs-comment">// 自定义标签路由逻辑</span><br>            ...<br><br>            <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>                logger.error(<span class="hljs-string">&quot;consumer tag:&quot;</span> + tag + <span class="hljs-string">&quot;not match same tag or not match empty tag provider&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result = filterInvoker(invokers, invoker -&gt; StringUtils.isEmpty(invoker.getUrl().getParameter(TAG_KEY)));<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="实现-RouterFactory-getRouter-方法">实现 RouterFactory getRouter 方法</h2><p>XxxRouterFactory.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xxx;<br><br><span class="hljs-keyword">import</span> org.apache.dubbo.rpc.cluster.RouterFactory;<br><span class="hljs-keyword">import</span> org.apache.dubbo.rpc.Invoker;<br><span class="hljs-keyword">import</span> org.apache.dubbo.rpc.Invocation;<br><span class="hljs-keyword">import</span> org.apache.dubbo.rpc.RpcException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XxxRouterFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RouterFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> Router <span class="hljs-title function_">getRouter</span><span class="hljs-params">(URL url)</span> &#123;<br>        <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">xxxTagRouter</span>(url)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基于-SPI-机制-加载-RouterFactory">基于 SPI 机制,加载 RouterFactory</h2><p>在 <code>META-INF/dubbo/org.apache.dubbo.rpc.cluster.RouterFactory</code>添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">xxx=com.xxx.XxxRouterFactory<br></code></pre></td></tr></table></figure><h1>其他</h1><h2 id="Dubbo-Provider-注册-url-添加参数">Dubbo Provider 注册 url 添加参数</h2><p>由于业务需要，provider 静态规则打标需要给把标签添加到 url 上，实现方法如下</p><p>实现<code>RegistryFactory</code> 使用包装类<code>RegistryWrapper</code> 中的 <code>appendProviderTag</code> 方法中给 url 添加 parameter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">xxxRegistryWrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RegistryFactory</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RegistryFactory registryFactory;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">xxxRegistryWrapper</span><span class="hljs-params">(RegistryFactory registryFactory)</span> &#123;<br>        <span class="hljs-built_in">this</span>.registryFactory = registryFactory;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Registry <span class="hljs-title function_">getRegistry</span><span class="hljs-params">(URL url)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegistryWrapper</span>(registryFactory.getRegistry(url));<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RegistryWrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Registry</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Registry originRegistry;<br><br>        <span class="hljs-keyword">private</span> URL <span class="hljs-title function_">appendProviderTag</span><span class="hljs-params">(URL url)</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">side</span> <span class="hljs-operator">=</span> url.getParameter(Constants.SIDE_KEY);<br>            <span class="hljs-keyword">if</span> (Constants.PROVIDER_SIDE.equals(side)) &#123;<br>                url = url.addParameter(<span class="hljs-string">&quot;TAG_KEY&quot;</span>, xxx);<br>            &#125;<br>            <span class="hljs-keyword">return</span> url;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">RegistryWrapper</span><span class="hljs-params">(Registry originRegistry)</span> &#123;<br>            <span class="hljs-built_in">this</span>.originRegistry = originRegistry;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> URL <span class="hljs-title function_">getUrl</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> originRegistry.getUrl();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAvailable</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> originRegistry.isAvailable();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>            originRegistry.destroy();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(URL url)</span> &#123;<br>            originRegistry.register(appendProviderTag(url));<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unregister</span><span class="hljs-params">(URL url)</span> &#123;<br>            originRegistry.unregister(appendProviderTag(url));<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subscribe</span><span class="hljs-params">(URL url, NotifyListener listener)</span> &#123;<br>            originRegistry.subscribe(url, listener);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unsubscribe</span><span class="hljs-params">(URL url, NotifyListener listener)</span> &#123;<br>            originRegistry.unsubscribe(url, listener);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> List&lt;URL&gt; <span class="hljs-title function_">lookup</span><span class="hljs-params">(URL url)</span> &#123;<br>            <span class="hljs-keyword">return</span> originRegistry.lookup(appendProviderTag(url));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Dirctory，Router，LoadBalance-和-Filter-调用顺序">Dirctory，Router，LoadBalance 和 Filter 调用顺序</h2><p><code>Dirctory</code>→Router→LoadBalance→Filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">组件              Directory              Router             LoadBalance      Filter<br>    产物     Invocation -----&gt;  List&lt;Invoker&gt; -----&gt; List&lt;Invoker&gt; -----&gt; Invoker -----&gt; Result<br>组件中的方法             list                 route                select         invoke<br></code></pre></td></tr></table></figure><h2 id="解决-Consumer-标签当前线程多次调用-dubbo-失效问题">解决 Consumer 标签当前线程多次调用 dubbo 失效问题</h2><p>由于 Dubbo 的 ContextFilter 特性会在调用结束时移除 Consumer 的上下文，tag 也因此移除，下次调用时没有标签因此需要在移除之前通过把 tag 保存下来。官方建议 也是通过 filter 设置<br><a href="https://github.com/apache/dubbo/issues/5638">https://github.com/apache/dubbo/issues/5638</a></p><p><code>We do that on purpose, you need to do some extra work to make the tag passed along the invoke chain. For example, you add a filter working before ContextFilter and save tag before it get removed.</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ContextFilter set the provider RpcContext with invoker, invocation, local port it is using and host for</span><br><span class="hljs-comment"> * current execution thread.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> RpcContext</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Activate(group = PROVIDER, order = -10000)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContextFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ListenableFilter</span> &#123;<br>...<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> invoker.invoke(invocation);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// IMPORTANT! For async scenario, we must remove context from current thread, so we always create a new RpcContext for the next invoke for the same thread.</span><br>    RpcContext.removeContext();<br>    RpcContext.removeServerContext();<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/dubbo-tag-invoker-chain/dubbo-tag-1662529.jpg" alt="dubbo-tag"></p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
      <tag>Java</tag>
      
      <tag>Router</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ShardingSphere 之 MySQL 数据迁移优化</title>
    <link href="/posts/004-shardingsphere-sacling-mysql-speed-increase.html"/>
    <url>/posts/004-shardingsphere-sacling-mysql-speed-increase.html</url>
    
    <content type="html"><![CDATA[<p>水平分库项目，用了 ShardingSphere-scaling 做数据迁移，由于存量数据迁移过程中过于缓慢，对数据迁移模块进行优化。</p><span id="more"></span><p>迁移效率提升 600%，校验效率提升 6000%。</p><table><thead><tr><th>表名</th><th>数据</th><th>迁移耗时</th><th>校验耗时</th></tr></thead><tbody><tr><td>screen_case</td><td>16000w</td><td>12h（优化前）</td><td></td></tr><tr><td>dc_rule_random</td><td>7000w</td><td>1h</td><td>8h（优化前）</td></tr><tr><td>ap_apply</td><td>14000w</td><td>2h</td><td>14m</td></tr><tr><td>ap_apply_ext</td><td>17000w</td><td>4h2m</td><td>18m</td></tr></tbody></table><h2 id="批量插入">批量插入</h2><p><code>rewriteBatchedStatements=true</code></p><p>改写存量数据为批量插入，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection()) &#123;<br>    connection.setAutoCommit(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> connection.prepareStatement(insertSql)) &#123;<br>        ps.setQueryTimeout(<span class="hljs-number">60</span>);<br>        <span class="hljs-keyword">for</span> (DataRecord record : list) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; record.getColumnCount(); i++) &#123;<br>                ps.setObject(i + <span class="hljs-number">1</span>, record.getColumn(i).getValue());<br>            &#125;<br>            ps.addBatch();<br>        &#125;<br>        ps.executeBatch();<br>    &#125;<br>    connection.commit();<br>&#125;<br></code></pre></td></tr></table></figure><p>当时以为这样写就可以了，但是迁移速度还是很慢只比原来单条插入快了一倍左右，经过研究发现，这并不是真正的批量插入，只是多条插入一次事务，降低了事务开销。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT IGNORE INTO `user`(`id`,`cust_no`,`age`,`name`,`delete_at`) VALUES(59985,&#x27;UR59985&#x27;,98,&#x27;name:1605538600723&#x27;,0) ;<br>INSERT IGNORE INTO `user`(`id`,`cust_no`,`age`,`name`,`delete_at`) VALUES(59986,&#x27;UR59986&#x27;,23,&#x27;name:160512312311&#x27;,0) ;<br></code></pre></td></tr></table></figure><p>在 MySQL JDBC 中，批操作的提交默认是逐条进行的。而在链接中加入以下参数，会把多条语句合并成一条提交。当 SQL 语句累积到一定数量（由数据库可接受的最大数据包大小决定），再一次性提交到数据库，减少了与数据库的交互次数，大大提高了效率。<code>rewriteBatchedStatements=true</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT IGNORE INTO `user`(`id`,`cust_no`,`age`,`name`,`delete_at`) VALUES(50200,&#x27;UR50200&#x27;,98,&#x27;name:1606138884516&#x27;,0),(50202,&#x27;UR50202&#x27;,98,&#x27;name:1606138884516&#x27;,0),(50204,&#x27;UR50204&#x27;,98,&#x27;name:1606138884516&#x27;,0);<br></code></pre></td></tr></table></figure><p>分析源码可以发现：<br>当 mysql 版本&gt;4.1.1，并且 rewriteBatchedStatements=true，批操作语句总数大于 4 条时（nbrCommands &gt; 4），才会合并成一条语句提交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">com.mysql.jdbc.StatementImpl#executeBatchInternal<br><br><span class="hljs-keyword">protected</span> <span class="hljs-type">long</span>[] executeBatchInternal() <span class="hljs-keyword">throws</span> SQLException &#123;<br>...<br>nbrCommands = (<span class="hljs-type">long</span>[])<span class="hljs-built_in">this</span>.batchedArgs.size();<span class="hljs-comment">// 获取批操作语句数量</span><br>    <span class="hljs-built_in">this</span>.batchedGeneratedKeys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(<span class="hljs-built_in">this</span>.batchedArgs.size());<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">multiQueriesEnabled</span> <span class="hljs-operator">=</span> locallyScopedConn.getAllowMultiQueries();<span class="hljs-comment">// 当前连接是否允许一次查询多条语句，默认为 false</span><br>    Object sqlEx;<br><span class="hljs-keyword">if</span> (locallyScopedConn.versionMeetsMinimum(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) &amp;&amp; (multiQueriesEnabled || locallyScopedConn.getRewriteBatchedStatements() &amp;&amp; nbrCommands &gt; <span class="hljs-number">4</span>)) &#123;<br>sqlEx = <span class="hljs-built_in">this</span>.executeBatchUsingMultiQueries(multiQueriesEnabled, (<span class="hljs-type">int</span>)nbrCommands, individualStatementTimeout);<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">long</span>[])sqlEx;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="预编译设置">预编译设置</h2><p>jdbc 客户端参数：</p><p>cachePrepStmts：默认 false.是否缓存 prepareStatement 对象。每个连接都有一个缓存，是以 sql 为唯一标识的 LRU cache. 同一连接下，不同 stmt 可以不用重新创建 prepareStatement 对象。</p><p>prepStmtCacheSize：LRU cache 中 prepareStatement 对象的个数。一般设置为最常用 sql 的个数。</p><p>prepStmtCacheSqlLimit：prepareStatement 对象的大小。超出大小不缓存。</p><h2 id="服务端编译">服务端编译</h2><p>useServerPrepStmts=false 关闭服务器端编译，sql 语句在客户端编译好再发送给服务器端。</p><p>如果为 true,sql 会采用占位符方式发送到服务器端，在服务器端再组装 sql 语句。</p><p>占位符方式：<code>INSERT INTO t (c1,c2) VALUES (？,？),(？,？),(？,？);</code></p><p>此方式就会产生一个问题，当列数*提交记录数&gt;65535</p><p>时就会报错：Prepared statement contains too many placeholders,</p><p>这是由于我把“提交记录数量”设为 10000，而要插入记录的表字段有 30 个，所以要进行批量插入时需要 30*10000=300000 &gt; 65535 ，故而报错。</p><p><strong>解决方案</strong></p><p>**方案 1：**把 DB 连接中的 rewriteBatchedStatements 给设置为 false（或者去掉），不过这个操作会影响数据的插入速度。</p><p>**方案 2：**更改表输出的设计。确保 30 个输出字段的和提交记录数量的乘积不超过 65535。比如把提交记录数量由 10000 更改为 450（30*2000=60000&lt; 65535）</p><p>当然我们的目的是为了提高数据库写速度，并且不考虑 sql 注入问题，所以当<code>rewriteBatchedStatements =true</code>时<code>useServerPrepStmts=false</code>配合使用较为合适。</p><h2 id="压缩数据传输">压缩数据传输</h2><p><code>useCompression=true</code>压缩数据传输，优化客户端和 MySQL 服务器之间的通信性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">com.mysql.jdbc.MysqlIO#doHandshake<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">doHandshake</span><span class="hljs-params">(String user, String password, String database)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br> ···<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Can&#x27;t enable compression until after handshake 在握手后</span><br>    才能启用压缩<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">if</span> (((<span class="hljs-built_in">this</span>.serverCapabilities &amp; CLIENT_COMPRESS) != <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-built_in">this</span>.connection.getUseCompression() &amp;&amp; !(<span class="hljs-built_in">this</span>.mysqlInput <span class="hljs-keyword">instanceof</span> CompressedInputStream)) &#123;<br>        <span class="hljs-comment">// The following matches with ZLIB&#x27;s compress()</span><br>        <span class="hljs-built_in">this</span>.deflater = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Deflater</span>();<br>        <span class="hljs-built_in">this</span>.useCompression = <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">this</span>.mysqlInput = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompressedInputStream</span>(<span class="hljs-built_in">this</span>.connection, <span class="hljs-built_in">this</span>.mysqlInput);<br>    &#125;<br>···<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_have_compress">https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_have_compress</a></p><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/shardingsphere-sacling-mysql-speed-increase/image-20201124001333217.png" alt="image-20201124001333217"></p><p>压缩协议提升网络传输性能，对于一些网络环境较差的用户会有很大的帮助，但是会相应地增加 CPU 开销，适用于传输数据量很大带宽不高的情况，这是一个 CPU 和网络资源的平衡问题。</p><p>经过测试 直连数据库会速度提高 5% 左右，效果不明显。通过 shardingsphere-proxy 连接数据库速度也并无明显提升</p><p>因此目前带宽无瓶颈的情况下，未使用压缩协议</p><p>直连数据库批量插入 5 分钟：</p><table><thead><tr><th>useCompression</th><th>100 条 avg</th><th>1000 条 avg</th><th>10000 条 avg</th></tr></thead><tbody><tr><td>true</td><td>11ms</td><td>42ms</td><td>307ms</td></tr><tr><td>false</td><td>12ms</td><td>43ms</td><td>321ms</td></tr></tbody></table><p>通过 shardingsphere-proxy 连接数据库批量插入 5 分钟：</p><table><thead><tr><th>useCompression</th><th>100 条 avg</th><th>1000 条 avg</th><th>10000 条 avg</th></tr></thead><tbody><tr><td>true</td><td>31ms</td><td>101ms</td><td>725ms</td></tr><tr><td>false</td><td>32ms</td><td>100ms</td><td>732ms</td></tr></tbody></table><p><strong>适用场景</strong></p><p>MySQL 压缩协议适合的场景是 MySQL 的服务器端和客户端之间传输的数据量很大，或者可用带宽不高的情况，典型的场景有如下两个：</p><p>a、查询大量的数据，带宽不够（比如导出数据的时候）；</p><p>b、复制的时候 binlog 量太大，启用 slave_compressed_protocol 参数进行日志压缩复制。</p><h3 id="压缩协议简介">压缩协议简介</h3><p>压缩协议是 MySQL 通信协议的一部分，要启用压缩协议进行数据传输，需要 MySQL 服务器端和客户端都支持 zlib 算法。启动压缩协议会导致 CPU 负载略微上升。使用启用压缩协议使用-C 参数或者 --compress=true 参数启动客户端的压缩功能。如果启用了-C 或者 compress=true 选项，那么在连接到服务器段的时候，会发送 0x0020（CLIENT_COMPRESS）的服务器权能标志位，和服务器端协商通过后（3 次握手以后），就支持压缩协议了。由于采用压缩，数据包的格式会发生变化，具体的变化如下：</p><p>未压缩的数据包格式：</p><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/shardingsphere-sacling-mysql-speed-increase/1497240545250_627_1497240545431.png" alt="img"></p><p>压缩后的数据包格式：</p><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/shardingsphere-sacling-mysql-speed-increase/1497240560529_3423_1497240560716.png" alt="img"></p><p>大家可能留意到压缩后的数据报格式有压缩和未压缩之分，这个是 MySQL 为了较少 CPU 开销而做的一个优化。如果内容小于 50 个字节的时候，就不对内容进行压缩，而大于 50 字节的时候，才会启用压缩功能。具体的规则如下：</p><p>当第三个字段的值等于 0x00 的时候，表示当前包没有压缩，因此 n<code>*</code>byte 的内容为 1<code>*</code>byte,n<code>*</code>byte，即请求类型和请求内容。</p><p>当第三个字段的值大于 0x00 的时候，表示当前包已采用 zlib 压缩，因此使用的时候需要对 n<code>*</code>byte 进行解压，解压后内容为 1<code>*</code>byte,n<code>*</code>byte，即请求类型和请求内容。</p><h2 id="结论">结论</h2><p><strong>原库读取数据设置</strong></p><p><code>useServerPrepStmts=true</code><br><code>cachePrepStmts=true</code></p><p><strong>新库插入数据设置</strong></p><p><code>rewriteBatchedStatements=true </code><br><code>useServerPrepStmts=false </code><br><code>useCompression=false</code></p><h2 id="参考文章">参考文章</h2><p><a href="https://my.oschina.net/u/4418437/blog/3648369">https://my.oschina.net/u/4418437/blog/3648369</a><br><a href="https://cloud.tencent.com/developer/article/1005252">https://cloud.tencent.com/developer/article/1005252</a><br><a href="https://www.cnblogs.com/lispking/p/3604063.html">https://www.cnblogs.com/lispking/p/3604063.html</a><br><a href="https://stackoverflow.com/questions/2506460/when-should-i-use-mysql-compressed-protocol">https://stackoverflow.com/questions/2506460/when-should-i-use-mysql-compressed-protocol</a><br><a href="https://blog.csdn.net/qq_43153418/article/details/104002252">https://blog.csdn.net/qq_43153418/article/details/104002252</a><br><a href="https://www.cnblogs.com/justfortaste/p/3920140.html">https://www.cnblogs.com/justfortaste/p/3920140.html</a></p>]]></content>
    
    
    <categories>
      
      <category>ShardingSphere</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ShardingSphere</tag>
      
      <tag>水平分库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ShardingSphere 之 Scaling</title>
    <link href="/posts/003-shardingsphere-scaling-introduce.html"/>
    <url>/posts/003-shardingsphere-scaling-introduce.html</url>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>ShardingSphere-Scaling 是一个提供给用户的通用的 ShardingSphere 数据接入迁移，及弹性伸缩的解决方案。</p><span id="more"></span><h2 id="使用方式">使用方式</h2><p>目前的弹性伸缩解决方案为：临时地使用两个数据库集群，伸缩完成后切换的方式实现。</p><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/shardingsphere-scaling-introduce/scaling-principle-overview.cn.png" alt="伸缩总揽"></p><p>这种实现方式有以下优点：</p><ol><li>伸缩过程中，原始数据没有任何影响</li><li>伸缩失败无风险</li><li>不受分片策略限制</li></ol><p>同时也存在一定的缺点：</p><ol><li>在一定时间内存在冗余服务器</li><li>所有数据都需要移动</li></ol><h2 id="执行步骤">执行步骤</h2><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/shardingsphere-scaling-introduce/image-20201216161515781.png" alt="image-20201216161515781"></p><h3 id="准备阶段">准备阶段</h3><p>在准备阶段，弹性伸缩模块会进行数据源连通性及权限的校验，同时进行存量数据的统计、日志位点的记录，最后根据数据量和用户设置的并行度，对任务进行分片。</p><h3 id="存量数据迁移阶段">存量数据迁移阶段</h3><p>执行在准备阶段拆分好的存量数据迁移作业，存量迁移阶段采用 JDBC 查询的方式，直接从数据节点中读取数据，并使用新规则写入到新集群中。</p><h3 id="增量数据同步阶段">增量数据同步阶段</h3><p>由于存量数据迁移耗费的时间受到数据量和并行度等因素影响，此时需要对这段时间内业务新增的数据进行同步。 不同的数据库使用的技术细节不同，但总体上均为基于复制协议或 WAL 日志实现的变更数据捕获功能。</p><ul><li>MySQL：订阅并解析 binlog</li><li>PostgreSQL：采用官方逻辑复制 <a href="https://www.postgresql.org/docs/9.4/test-decoding.html">test_decoding</a></li></ul><p>这些捕获的增量数据，同样会由弹性伸缩模块根据新规则写入到新数据节点中。当增量数据基本同步完成时（由于业务系统未停止，增量数据是不断的），则进入规则切换阶段。</p><h3 id="规则切换阶段">规则切换阶段</h3><p>在此阶段，可能存在一定时间的业务只读窗口期，通过业务停止写入或设置数据库只读或 ShardingSphere 的熔断机制，让旧数据节点中的数据短暂静态，确保增量同步已完全完成。</p><p>这个窗口期时间短则数秒，长则数分钟，取决于数据量和用户是否需要对数据进行强校验。 确认完成后，Apache ShardingSphere 可通过配置中心修改配置，将业务导向新规则的集群，弹性伸缩完成。</p><p>我们由于有写业务无法无法完全停止写入，目前只能尽可能减少写入，然后开启双写，并且停止迁移，进行数据校验，对有问题数据进行补处理。</p><h2 id="架构设计">架构设计</h2><h3 id="ScalingTask">ScalingTask</h3><p>任务最小执行单元</p><p>主要实现类：</p><ul><li>InventoryDataScalingTask（History）存量</li><li>IncrementalDataScalingTask（RealTime） 增量</li></ul><h3 id="Dumper（Reader）">Dumper（Reader）</h3><p>从原库获取数据，核心操作主要有：</p><ul><li>setChannel(Channel channel); 设置 Channel</li><li>dump(); 从原库获取数据，并保存数据到 channel 中</li></ul><p>主要实现类：</p><ul><li>JDBCDumper</li><li>LogDumper</li></ul><h3 id="Importer（Writer）">Importer（Writer）</h3><p>把数据写入数据到新库,核心操作主要有：</p><ul><li>setChannel(Channel channel); 设置 Channel</li><li>write(); 写入数据到数据库</li></ul><h3 id="Channel">Channel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Channel</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushRecord</span><span class="hljs-params">(Record dataRecord)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    List&lt;Record&gt; <span class="hljs-title function_">fetchRecords</span><span class="hljs-params">(<span class="hljs-type">int</span> batchSize, <span class="hljs-type">int</span> timeout)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">ack</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>主要实现类：</p><ul><li>MemoryChannel</li><li>DistributionChannel</li></ul><h3 id="存量迁移">存量迁移</h3><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/shardingsphere-scaling-introduce/image-20201216175534892.png" alt="image-20201216175534892"></p><ol><li><p>获取 minId、maxId，并根据 id 和 concurrency 把迁移 id 区间平均分配到各个 Task（InventoryDataScalingTask）。</p><p>minId=1，maxId=100，concurrency=10，则</p><p>task1 id 区间为 1-10，task2 id 区间为 11-20 …</p></li><li><p>每个 Task 都有一个 dumper 从原库批量获取 DataRecord，并 push 到 MemoryChannel，BlockingQueue 长度为 10000，超过则阻塞等待</p></li><li><p>Importer 从 MemoryChannel 批量获取 DataRecord 并依次插入到新库中，然后 ack()。</p></li><li><p>当 dumper 获取不到数据时，则 push 一个 FinishedRecord 到 MemoryChannel，dumper 结束。</p></li><li><p>Importer 获取到 FinishedRecord 时，Importer 结束，Task 执行完毕。</p></li></ol><h3 id="增量迁移">增量迁移</h3><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/shardingsphere-scaling-introduce/image-20201216175621918.png" alt="image-20201216175621918"></p><ol><li><p>每次 Task（InventoryDataScalingTask）执行完成，callBack 检测是否所有 Task（InventoryDataScalingTask）执行完成。都执行完成开启增量迁移 Task（IncrementalDataScalingTask）。</p></li><li><p>增量只有一个 dumper 从迁移开始时记录的 binlog 位置 subscribe 数据，并根据 hashcode 和 channelNumber 取模 push 到 Memorychannel。</p><p>String index = Integer.toString(Math.abs(dataRecord.hashCode()) % channelNumber);</p></li><li><p>Importer 从 MemoryChannel 批量获取 DataRecord 并依次插入/更新到新库中，然后 ack()。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>ShardingSphere</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ShardingSphere</tag>
      
      <tag>水平分库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ShardingSphere 介绍</title>
    <link href="/posts/002-shardingsphere-introduce.html"/>
    <url>/posts/002-shardingsphere-introduce.html</url>
    
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p><a href="https://shardingsphere.apache.org/">ShardingSphere 官网</a></p><p>Apache ShardingSphere 是一套开源的分布式数据库中间件解决方案组成的生态圈，它由 JDBC、Proxy 和 Sidecar（规划中）这 3 款相互独立，却又能够混合部署配合使用的产品组成。 它们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如 Java 同构、异构语言、云原生等各种多样化的应用场景。</p><span id="more"></span><p>Apache ShardingSphere 定位为关系型数据库中间件，旨在充分合理地在分布式的场景下利用关系型数据库的计算和存储能力，而并非实现一个全新的关系型数据库。 它通过关注不变，进而抓住事物本质。关系型数据库当今依然占有巨大市场，是各个公司核心业务的基石，未来也难于撼动，我们目前阶段更加关注在原有基础上的增量，而非颠覆。</p><p>Apache ShardingSphere 5.x 版本开始致力于可插拔架构，项目的功能组件能够灵活的以可插拔的方式进行扩展。 目前，数据分片、读写分离、数据加密、影子库压测等功能，以及对 MySQL、PostgreSQL、SQLServer、Oracle 等 SQL 与协议的支持，均通过插件的方式织入项目。 开发者能够像使用积木一样定制属于自己的独特系统。Apache ShardingSphere 目前已提供数十个 SPI 作为系统的扩展点，而且仍在不断增加中。</p><p>ShardingSphere 已于 2020 年 4 月 16 日成为 <a href="https://apache.org/index.html#projects-list">Apache 软件基金会</a>的顶级项目。</p><h3 id="ShardingSphere-JDBC">ShardingSphere-JDBC</h3><p>定位为轻量级 Java 框架，在 Java 的 JDBC 层提供的额外服务。 它使用客户端直连数据库，以 jar 包形式提供服务，无需额外部署和依赖，可理解为增强版的 JDBC 驱动，完全兼容 JDBC 和各种 ORM 框架。</p><ul><li>适用于任何基于 JDBC 的 ORM 框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template 或直接使用 JDBC。</li><li>支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP 等。</li><li>支持任意实现 JDBC 规范的数据库，目前支持 MySQL，Oracle，SQLServer，PostgreSQL 以及任何遵循 SQL92 标准的数据库。</li></ul><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/shardingsphere-introduce/image-20201216153825102.png" alt="image-20201216153825102"></p><h3 id="ShardingSphere-Proxy">ShardingSphere-Proxy</h3><p>定位为透明化的数据库代理端，提供封装了数据库二进制协议的服务端版本，用于完成对异构语言的支持。 目前提供 MySQL 和 PostgreSQL 版本，它可以使用任何兼容 MySQL/PostgreSQL 协议的访问客户端(如：MySQL Command Client, MySQL Workbench, Navicat 等)操作数据，对 DBA 更加友好。</p><ul><li>向应用程序完全透明，可直接当做 MySQL/PostgreSQL 使用。</li><li>适用于任何兼容 MySQL/PostgreSQL 协议的的客户端。</li></ul><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/shardingsphere-introduce/shardingsphere-proxy-brief.png" alt="ShardingSphere-Proxy Architecture"></p><h3 id="ShardingSphere-Scaling">ShardingSphere-Scaling</h3><p>ShardingSphere-Scaling 是一个提供给用户的通用的 ShardingSphere 数据接入迁移，及弹性伸缩的解决方案。</p><h3 id="ShardingSphere-UI">ShardingSphere-UI</h3><p>ShardingSphere-UI 是 ShardingSphere 的一个简单而有用的 web 管理控制台。它用于帮助用户更简单的使用 ShardingSphere 的相关功能，目前提供注册中心管理、动态配置管理、数据库编排等功能。</p><p>项目结构上采取了前后端分离的方式，前端使用 Vue 框架，后端采用 Spring Boot 框架。使用标准的 Maven 方式进行打包，部署，同时也可以采用前后端分离的方式本地运行，方便开发调试。</p><h3 id="ShardingSphere-Sidecar（TODO）">ShardingSphere-Sidecar（TODO）</h3><p>定位为 Kubernetes 的云原生数据库代理，以 Sidecar 的形式代理所有对数据库的访问。 通过无中心、零侵入的方案提供与数据库交互的的啮合层，即 <code>Database Mesh</code>，又可称数据库网格。</p><p>Database Mesh 的关注重点在于如何将分布式的数据访问应用与数据库有机串联起来，它更加关注的是交互，是将杂乱无章的应用与数据库之间的交互进行有效地梳理。 使用 Database Mesh，访问数据库的应用和数据库终将形成一个巨大的网格体系，应用和数据库只需在网格体系中对号入座即可，它们都是被啮合层所治理的对象。</p><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/shardingsphere-introduce/shardingsphere-sidecar-brief.png" alt="ShardingSphere-Sidecar Architecture"></p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"><em>ShardingSphere-JDBC</em></th><th style="text-align:left"><em>ShardingSphere-Proxy</em></th><th style="text-align:left"><em>ShardingSphere-Sidecar</em></th></tr></thead><tbody><tr><td style="text-align:left">数据库</td><td style="text-align:left">任意</td><td style="text-align:left">MySQL/PostgreSQL</td><td style="text-align:left">MySQL/PostgreSQL</td></tr><tr><td style="text-align:left">连接消耗数</td><td style="text-align:left">高</td><td style="text-align:left">低</td><td style="text-align:left">高</td></tr><tr><td style="text-align:left">异构语言</td><td style="text-align:left">仅 Java</td><td style="text-align:left">任意</td><td style="text-align:left">任意</td></tr><tr><td style="text-align:left">性能</td><td style="text-align:left">损耗低</td><td style="text-align:left">损耗略高</td><td style="text-align:left">损耗低</td></tr><tr><td style="text-align:left">无中心化</td><td style="text-align:left">是</td><td style="text-align:left">否</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">静态入口</td><td style="text-align:left">无</td><td style="text-align:left">有</td><td style="text-align:left">无</td></tr></tbody></table><h3 id="应用">应用</h3><p>ShardingSphere-JDBC 采用无中心化架构，用于 Java 开发的高性能的轻量级应用。</p><p>ShardingSphere-Proxy 提供静态入口以及异构语言的支持，用于数据迁移及运维查询。</p><p>ShardingSphere-Scaling 用于数据迁移。</p><p><img src="https://zheng-1259265883.cos.ap-guangzhou.myqcloud.com/img/blog-history/shardingsphere-introduce/image-20201216154030084.png" alt="image-20201216154030084"></p>]]></content>
    
    
    <categories>
      
      <category>ShardingSphere</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ShardingSphere</tag>
      
      <tag>水平分库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/001-hello-world.html"/>
    <url>/posts/001-hello-world.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to my site.</p><span id="more"></span>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
